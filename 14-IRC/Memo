https://modern.ircdocs.horse/

Modern IRC Client Protocol

Intro
Le protocole IRC (Internet Relay Chat) est un protocole de chat basé sur le texte.
Il est adapté (well-suited) pour fonctionner sur plusieurs machines de manière distribuée (par
opposition à une organisation centralisée) (1).
Une configuration typique implique plusieurs serveur connectés dans un réseau distribué.
Les messages sont délivrés à travers ce réseau et l'état des clients connectés et des canaux
actifs y est maintenu.

-----------------------------------------------------------------------------------------------

IRC concepts

Cette section décrit les concepts derrière la mise en oeuvre et l'organisation du protocole IRC.

	1-Architecture :
	Un reseau IRC typique comprend des serveurs et des clients connectés à ces serveurs,
	avec un bon mélange d'opérateurs IRC et de canaux. Cette section décrit succintement
	ce qu'ils sont.

-----------------------------------------------------------------------------------------------
	
		1.1-Les serveurs :
		
		Les serveurs constituent la colonne vertébrale (backbone) d'IRC, fournissant
		un point à partir duquel les clients peuvent se connecter et se parler aux uns
		les autres, et un point auquel les autres serveurs peuvent se connecter,
		formant un réseau IRC.
		
		La configuration la plus commune pour le réseau de serveurs IRC est celle du
		spanning (enchevêtrement) tree (racine d'arbre ?), dans laquelle chaque serveur
		agit comme un noeud central pour le reste du réseau qu'il voit (voir figure 1).
		NB : d'autres configurations ont été experimentées, mais à ce jour, aucune n'a
		été utilisée largement en production.
		
		Plusieurs termes ont été créés au fil du temps pour décrire les rôles des
		différents serveurs sur un réseau IRC. Les plus communs sont les suivants :
		
			- Hub : un hub est un serveur qui est relié à plusieurs autres
			serveurs. C'est le cas des serveurs 2, 3 et 4 dans la figure 1.

			- Core Hub : un "Core Hub" est typiquement un serveur hub qui relie
			entre elles des parties relativement importantes du réseau IRC. La
			notion d'importance dépendra de la taille du réseau et de
			l'appréciation de l'administrateur. Ce pourrait être le cas pour les
			serveurs 1, 2, 3 dans la figure 1.
			
			- Leaf : un leaf (feuille) est un serveur qui est connecté à un seul
			serveur sur le réseau. Ce serait le cas, entre autres, pour les
			serveurs 7, 8, 10, 13, 14 dans la figure 1.
			
			- Services : un serveur "services" est un serveur spécial qui étend
			les capacités du logiciel (software) serveur sur le réseau
			(ie, il fournit des services au réseau). Les services ne sont pas
			utilisés sur tous les réseaux et les services qu'ils sont susceptibles
			de fournir sont plutôt inclus dans les logiciels réseau grâce à des
			paquets séparés.
			Les fonctionnalités (features) généralement gérées par les services
			incluent :
				- l'enregistrement des comptes client (voir SASL
				authentication),
				- l'enregistrement des canaux (permettant aux comptes clients
				de posséder leurs propres canaux,
				- la possibilité de modifications ultérieures et d'extensions
				du protocole IRC. 
			Ces services sont différents des services définis par le RFCs (Requests
			for Comments = documentation technique associés à internet  et au
			protocole IRC).
		Une tendance (trend) actuelle est de cacher la structure du réseau aux
		utilisateurs "standards" (regular). Les réseaux qui sont ainsi mis en oeuvre
		peuvent restreindre ou modifier les commandes telles que 'MAP' de telle façon
		que les utilisateurs "standards" voient tous les autres serveurs sur le réseau
		comme s'ils étaient connectés directement au serveur courant. Ainsi, les
		serveurs qui ne gèrent pas les connections client sont susceptibles d'être
		cachés (dans ce cas les serveurs hub peuvent être appelés 'hidden hubs'). En
		général les opérateurs IRC peuvent toujours voir la structure en arbre du
		réseau.
		
		En genéral, ces termes n'apparaissent pas dans la documentation IRC, mais sont
		susceptibles d'être utilisés pas les administrateurs réseau pour différencier
		le rôle des serveurs qu'ils gèrent.
		
		Le nom des serveurs devraient contenir un point (".").

-----------------------------------------------------------------------------------------------

		1.2-Les clients :

		Un client est tout ce qui est connecté à un serveur et qui n'est pas un autre
		serveur.
		Chaque client se distingue d'un autre client pas un surnom (nickname) unique.
		En plus	du surnom, tous les serveurs doivent diposer d'informations
		complémentaires à propos de tous les clients :
			- le nom réel,
			- l'adresse de l'hôte auquel le client est connecté,
			- le nom d'utilisateur du client sur l'hôte,
			- le serveur auquel le client est connecté.
		Les surnoms sont des chaînes de caractères non vides avec les restrictions
		suivantes :
			- ils ne doivent contenir aucun des caractères suivants :
				- space ' ',
				- comma ',',
				- asterisk '*',
				- question mark '?',
				- exclamation mark '!',
				- at sign '@'.
			- ils ne doivent pas commencer par les caractères suivants :
				- dollar '$',
				- colon ':'.
			- ils ne doivent pas commencer par un caractère définis comme un
			"channel type", un "channel membership prefix", ou par un prefix
			définis dans la liste.
			- ils ne doivent contenir aucun dot character '.'.
		Les serveurs peuvent ajouter des restrictions supplémentaires sur les surnoms
		et doivent éviter l'utilisation de surnoms qui pourraient porter à confusion
		vis à vis de commandes ou de paramètres de commande. 

-----------------------------------------------------------------------------------------------

		1.3-Les services :
		
		Ils ne sont plus utilisés à ce jour. (???)

-----------------------------------------------------------------------------------------------

		1.4-Les opérateurs :
		
		Afin de maintenir un ordre raisonnable au sein du réseau IRC, une catégorie
		spéciale de clients (opérateurs) est autorisée à effectuer (perform) des tâches
		de maintenance générale sur le réseau.
		Bien que les pouvoirs accordés à un opérateur puissent être considérés comme
		"dangereux", ils sont néanmoins nécessaires.
		
		Les tâches que les opérateurs peuvent effectuer varient en fonction des
		logiciels serveur et des privilèges accordés (granted) à chaque opérateur.
		Certains peuvent effectuer des tâches de maintenance sur le réseau, tel que
		déconnecter et reconnecter des serveurs comme cela peut être nécessaire pour
		prévenir l'utilisation à long terme d'un mauvais routage de réseau.
		Certains opérateurs peuvent également forcer la suppression d'un utilisateur
		de leur serveur	ou du réseau, autrement dit un opérateur est capable de fermer
		la connection entre un client et son serveur.
		
		NB : La justification de la possibilité pour les opérateurs de retirer des
		utilisateurs du réseau est délicate, car l'abus est à la fois destructeur et
		ennuyeux.
		Cependant, les politiques et les administrateurs des réseaux IRC gèrent les
		opérateurs qui abusent de leurs privilèges, et ce qui est considéré comme un
		abus par ce réseau.

-----------------------------------------------------------------------------------------------

		1.5-Les canaux (channels) :
		
		Un canal est un groupe identifié de un ou plusieurs clients.
		Tous les clients dans un canal vont recevoir tous les messages adressés à ce
		canal.
		Le canal est implicitement créé quand le premier client le rejoint, et le canal
		cesse (ceases) d'exister quand le dernier client le quitte. Tant que le canal
		existe,	tout client peut y faire référence en utilisant le nom du canal.
		Les réseaux qui prennent en charge le concept de propriété des canaux (channel
		ownership) peuvent maintenir des canaux spécifiques d'une certaine manière
		alors qu'aucun client n'y est connecté.

		Les noms des canaux sont des chaînes de caractères (qui commencent par des
		caractères spécifiques en préfixe). Mis à part cette exigence, la seule
		restriction concernant le nom du canal est qu'il ne peut pas contenir :
			- de space ' ',
			- de control G / BELL '^G',
			- de comma ',' (qui sont utilisés comme séparateurs dans une liste
			d'items).
		
		Il existe plusieurs types de canaux utilisés par le protocole IRC.
		Le premier type de canal est le canal ordinaire (regular channel) qui est connu
		par tous les serveurs qui sont connectés au réseau. Le préfixe de ce canal est
		le #.
		Le deuxième type est un serveur specifique ou canal local (local channel), dans
		lequel les clients connectés peuvent uniquement voir et parler aux autres
		clients sur le même serveur. Le préfixe de ce canal est le &.
		Les autres types de canaux seront décrits ultérieurement dans la section
		"Channel Types".
		
		Outre les différents types de canaux, il existe également des modes de canaux
		qui peuvent modifier les caractéristiques et le comportement des canaux
		individuels. Se référer à la section "Channel Modes" pour plus d'informations
		sur ceux-ci.
		
		Pour créer un nouveau canal ou rejoindre un canal existant, l'utilisateur doit
		utiliser la commande JOIN.
		Si le canal n'existe pas préalablement, le canal est créé et l'utilisateur créé
		devient un opérateur de canal (channel operator).
		Si le canal existe déjà, le fait que le client réussisse ou non à rejoindre ce
		canal dépend des modes actuellement définis sur le canal. Par exemple, si le
		canal est défini (set) dans une mode invite-only (+i), le client ne pourra
		rejoindre le canal que si il a été invité par un autre utilisateur ou si il a
		été dispensé d'une invitation par les opérateurs (channel operators).
		
		Les canaux peuvent également contenir un thème (topic). Le thème est une ligne
		visible par tous les utilisateurs quand ils rejoignent le canal et tous les
		utilsateurs sont informés lors d'un changement de thème sur un canal.
		Les thèmes de canaux énoncent généralement les règles du canal, les liens, les
		citations des membres du canal, ou tout ce que les opérateurs du canal
		souhaitent partager (share) avec les clients de leur canal.
		
		Un utilisateur peut faire partie de plusieurs canaux simultanément, mais une
		limite peut être imposée par le serveur.
		Cette limite est spécifiée par le paramètre CHANLIMIT RPL_ISUPPORT. Se reporter
		à la section "Feature Advertisement" pour plus de détails.
		
		Si le réseau IRC devient disjoint en raison d'une scission entre serveurs, le
		canal de chaque côté est composé uniquement des clients qui sont connectés aux
		serveurs des côtés respectifs de la scission, et peut cesser d'exister d'un
		côté.
		Lorsque la séparation est réparée, les serveurs connectés s'assurent que
		l'état du réseau est cohérent entre eux.
		
-----------------------------------------------------------------------------------------------
		
		1.6-Les opérateurs de canaux (channels operators or chanops) :

		Les "chanops" d'un canal donné sont considérés comme gérant ou propriétaire de
		ce canal. 
		En reconnaissance (in recognition of) de ce statut, les "chanops" sont dotés de
		(are enowed with) certains pouvoirs qui leur permettent de modérer (moderate)
		et de garder le contrôle de leur canal.

		La plupart des opérateurs IRC ne se préoccupent pas de la "politique des
		canaux".
		En outre, un grand nombre de réseaux laisse la gestion des canaux spécifiques
		aux "chanops" dans les cas où cela est possible, et essaient de ne pas
		interférer eux-même.
		Toutefois, il s'agit d'une question de politique de réseau, et il est préférable
		de consulter le message du jour (Message Of The Day = MOTD command) lorsqu'on
		s'intéresse à la gestion des canaux.
		
		Les serveurs IRC peuvent aussi définir d'autres niveaux de modération de canal.
		Il peut s'agir :
			- de "halfop" (half operator),
			- de "protected" (protected user/operator),
			- de "founder" (channel founder),
			- de toute autre position que le serveur souhaite définir.
		Ces niveaux de modération ont des privilèges variés et peuvent exécuter, ou
		non, de nombreuses commandes de gestion de canal basés sur les choix du serveur.
		
		Les commandes qui ne peuvent être utilisées que par les modérateurs de canal
		sont les suivantes :
			- KICK : éjecter un client du canal,
			- MODE : changer les modes du canal,
			- INVITE : inviter un client sur un canal "invite-only" (mode +i),
			- TOPIC : modifier le thème du canal (mode +t).
		
		Les modérateurs de canal sont identifiés par le préfixe de membre du canal
		('@' pour les opérateurs de canaux standards, '%' pour les "halfops") suivi
		de leur "nickname" à chaque fois qu'il est associé à un canal (voir les
		commandes NAMES, WHO, WHOIS).
		
		Les préfixes spécifiques et les niveaux de modération sont décrits dans la
		section "Channel Membership Prefixes".
		
		
-----------------------------------------------------------------------------------------------

	2-Types de communication :
	
	Cette section décrit comment les implémentations actuelles délivrent différentes
	classes de message (de façon non normative).
	
	Cette section traite UNIQUEMENT de la topologie spanning-tree (voir figure 2).
	
-----------------------------------------------------------------------------------------------

		2.1-Communication "one-to-one" :
		
		La communication sur la base one-to-one La communication individuelle n'est
		généralement effectuée que par les clients, car la majeure partie du trafic
		serveur-serveur ne résulte pas du fait que les serveurs ne parlent qu'entre
		eux (???).
		
		Les serveurs devraient être capable d'envoyer un message de n'importe quel
		client à un autre. Les serveurs envoient un message dans exactement une
		direction le long du "spanning tree" pour atteindre n'importe quel client.
		Toutefois, le chemin emprunté par le message qui doit être déivré est le plus
		court chemin entre deux point du "spanning tree".
		
		Les examples suivants suivent le schéma de la figure 2 :
			- un message entre les clients 1 et 2 n'est vu que par le serveur A,
			qui l'envoie directement au client 2.
			- un message entre les clients 1 et 3 est vu par les serveurs A et B,
			et par le client 3. Aucun autre client ou serveur n'est autorisé à voir
			le message.
			- un message entre les clients 2 et 4 est vu par les serveurs A, B, C
			et D, et par le client 4 seulement.
			 
-----------------------------------------------------------------------------------------------

		2.2-Communication "one-to-many" :

		Le but principal d'IRC est de fournir un forum qui permet des conférences
		(conferencing) faciles et efficaces (conversations entre plusieurs personnes
		"one-to-many).
		IRC offre plusieurs moyens (means) pour y arriver, chacun servant son propre
		but.
		
		2.2.1-To A Channel :
		
		Dans IRC, le canal joue un rôle equivalent à celui d'un groupe multicast ;
		leur existence est dynamique et la conversation proprement dite sur un canal
		est généralement envoyée seulement aux serveurs qui supportent les utilisateurs
		sur un canal donné, et une seule fois à chaque lien local, car chaque serveur
		est chargé de diffuser (fanning) le message original pour s'assurer qu'il
		atteindra tous les destinataires (recipients).

		Les examples suivants suivent le schéma de la figure 2 :
			- pour tout canal ne contenant aucun client, les messages à destination
			de ce canal vont au serveur puis nulle part ailleurs.
			- deux clients dans un canal : tous les messages traversent un chemin
			comme s'il s'agissait de messages privés entre les deux clients en
			dehors d'un canal (???).
			- les clients 1, 2 et 3 sont dans un canal. Tous les messages destinés
			à ce canal sont envoyés à tous les clients et uniquement aux serveurs
			qui doivent être traversés par le message s'il s'agit d'un message
			privé destiné à un seul client. Si le client 1 envoie un message, il
			retourne au client 2 et ensuite au client 3 via le serveur B.
		
		2.2.2-To A Host / Server Mask :
		
		Pour disposer (to provide with) d'un mécanisme permettant d'envoyer des
		messages à un grand nombre d'utilisateurs apparentés (related users), il existe
		des messages de masque d'hôte et de serveur.
		Ces messages sont envoyés aux utilisateurs dont l'information d'hôte ou de
		serveur correspond au masque donné.
		Les messages ne sont envoyés qu'aux endroits où se trouvent les utilisateurs,
		d'une manière similaire à celle des canaux.
		
		2.2.3-To A List :
		
		La type le moins efficace de communication one-to-many se fait au travers de
		clients s'adressant à une liste de cibles (clients, canal, requête).
		La façon de procéder est presque explicite : le client donne une liste de 
		destinataires auxquels le message doit être délivré, le serveur le décompose
		(breaks it up) et répartit une copie séparée du message à chaque destinatation
		donnée.
		
		Ce n'est pas aussi efficace que d'utiliser un canal car la liste de destination
		peut être fragmentée (broken up) et la répartition peut être faite sans
		vérfication pour s'assurer que les doublons ne sont pas envoyés par chaque
		chemin.

-----------------------------------------------------------------------------------------------

		2.2-Communication "One-To-All" :
		
		Le type de message "one-to-all" est mieux décrit comme un message de diffusion
		(broadcast message), envoyé à tous les clients ou serveurs ou les deux.
		Sur un large réseau d'utilisateurs et de serveurs, un seul message peut
		entraîner l'envoi d'une grande quantité de trafic sur le réseau pour tenter
		d'atteindre toutes les destinations souhaitées.
		
		Pour certaines catégories de messages, il n'existe pas d'autre choix que de les
		diffuser à tous les serveurs afin que les informations d'état détenues par
		chaque serveur soient cohérentes (consistent) entre elles.
		
		2.2.1-Client-to-Client :
		
		Les opérateurs IRC peuvent être capables d'envoyer un message à tous les client
		actuellement connectés au réseau. Cela dépend des fonctions (features) et des
		commandes spécifiques implémentées dans le logiciel du serveur.
		
		2.2.2-Client-to-Serveur :
		
		La plupart des commandes qui entraînent (result) un changement d'état des
		informations (tel que l'appartenance à un canal (channel membership), le mode
		de fonctionnement des canaux (channel modes), le statut des utilisateurs (user
		status), etc ...) doivent être envoyées à tous les serveurs par défaut, et
		cette distribution ne doit pas être modifiée par le client.
		
		2.2.3-Server-to-Server :

		Alors que la plupart des messages entre les serveurs sont distribués à tous les
		autres serveurs, cela n'est nécessaire que pour tout message affectant un
		utilisateur, un canal ou un serveur.
		Comme il s'agit des éléments de base de l'IRC, presque tous les messages
		provenant d'un serveur sont diffusés à tous les autres serveurs connectés.
		
-----------------------------------------------------------------------------------------------

Connection Setup :

Les connexions client-server fonctionnent sur un protocole TCP/IP.
Les ports standards utilisés pour les connectons client-serveur sont le port TCP/6667 pour le
texte (plaintext), et le port TCP/6697 pour les connexions TLS.

-----------------------------------------------------------------------------------------------

Structure du protocole server-to-server (S2S) :

Les référentiels RFC1459 et RFC2813 définissent un protocole server-to-server. Mais depuis une
dizaine d'années, les implémentations ont étendu ce protocole et ont divergé, et les serveurs
ont entièrement créé de nouveaux protocoles.

Toutefois, les différentes implémentations d'IRC n'ont pas besoin d'interagir les unes avec les
autres.
En général, les réseaux utilisent un logiciel serveur sur la totalité de leur réseau, et ils
utilisent le protocole S2S implémenté par ce serveur. Le protocole client est important, mais
la façon dont les serveurs communiquent entre eux sur le réseau est considéré comme un détail
d'implémentation. 

-----------------------------------------------------------------------------------------------

Structure du protocole client-to-serveur :

Lorsqu'un client est connecté à un serveur, ils s'envoient un flux d'octets l'un à l'autre.
Ces flux contiennent des messages séparés par un retour chariot (CR) ('\r') et fin de ligne
(LF) ('\n').
Ces messages peuvent être envoyés à n'importe quel moment depuis l'autre côté, et peuvent
générer un zero ou d'autres messages en réponse.

Le logiciel doit utiliser l'encodage de caractère UTF-8 pour encoder et décoder les messages,
avec des solutions de repli (fallbacks) telles que décrites dans l'annexe sur les considérations relatives à la mise en œuvre des encodages de caractères.

Les noms des entités IRC (clients, serveurs, canaux) sont "casemapped" (???).
Ceci évite, par exemple, que quelqu'un porte le nom 'Dan' et que quelqu'un d'autre porte le
surnom 'dan', ce qui porterait à confusion.
Les serveurs doivent annoncer (advertise) le "casemapping" qu'ils utilisent dans le
RPL_ISUPPORT (support (documentation ?) numerique) qui est envoyé lorsque l'enregistrement de
la connexion est terminé (has completed).

-----------------------------------------------------------------------------------------------
	
	1-Le format du message :
	
	Un message IRC est une simple ligne, délimitée par une paire de caractères ('\r', '\n').

		- le lecture des données entrantes se fait dans un buffer.
		La parsing et l'analyse d'un message ne se font qu'une fois la paire de
		caractéres rencontrée à la fin du message. Si un message vide est rencontré,
		il est ignoré, sans produire de message spécifique.
		- à l'envoi des messages, il faut s'assurer de la présence de la paire de
		caractères suivant chaque simple message.
	
		Exemple de message (conforme à la grammaire ABNF (2)) :

message         ::= ['@' <tags> SPACE] [':' <source> SPACE] <command> <parameters> <crlf>
SPACE           ::=  %x20 *( %x20 )   ; space character(s)
crlf            ::=  %x0D %x0A        ; "carriage return" "linefeed"

		Dans le message, plusieurs parties spécifiques se distinguent :
			- tags : ce sont des métadonnées optionnelles, qui commencent
			par '@',
			- source : note optionnelle qui définit la provenance du message, qui
			commence par ':',
			 - command : la commande spécifique que le message représente,
			 - parameters : si il existe, les données relatives (relevant) à cette
			 commande spécifique.
		Ces parties du message, et les paramètres eux-mêmes, sont séparés par un ou
		plusieurs espaces (' ').
		
		La plupart des serveurs IRC limitent les message à une longueur de 512 octets,
		ce qui inclue la paire de caractères de fin.
		Les implémentations qui incluent des tags ont besoin d'allouer des octets
		supplémentaires pour la partie tags d'un message ; les clients doivent allouer
		8191 octets supplémentaires et les serveurs 4096 octets supplémentaires.

-----------------------------------------------------------------------------------------------

Les sections suivantes décrivent comment traiter chaque partie, mais voici quelques exemples
de messages complets :

:irc.example.com CAP LS * :multi-prefix extended-join sasl


-----------------------------------------------------------------------------------------------

(1)CHATGPT :

How could you explain what is a distributed fashion in IT ?

ChatGPT said:

In IT, a distributed fashion refers to the way a system, application, or process is designed
to operate across multiple locations, computers, or nodes, rather than being centralized on a
single machine or site. This concept is foundational in distributed computing and systems,
allowing for scalability, fault tolerance, and optimized performance.

Key Characteristics of a Distributed Fashion:
	1.Decentralization: Instead of relying on one central server, tasks and data are shared
	across multiple nodes in the system.
	2.Parallelism: Tasks can be processed simultaneously across multiple locations,
	increasing speed and efficiency.
	3.Redundancy: Data and services are often replicated across nodes, improving
	reliability and fault tolerance.
	4.Communication: Nodes interact and communicate with each other, often over a network,
	to ensure coordination and consistency.

Examples of Distributed Fashion in IT:
	1.Cloud Computing: Services like Amazon Web Services (AWS) or Microsoft Azure
	distribute resources and workloads across global data centers.
	2.Content Delivery Networks (CDNs): Systems like Akamai or Cloudflare distribute web
	content across servers worldwide to improve access speed.
	3.Blockchain: A distributed ledger system where transactions are recorded across
	multiple nodes, ensuring transparency and decentralization.
	4.Distributed Databases: Databases like Cassandra or MongoDB store data across multiple
	servers, enabling scalability and high availability.

In short, working in a distributed fashion allows IT systems to be more scalable, reliable,
and efficient by leveraging the power of multiple interconnected resources.
purpose

-----------------------------------------------------------------------------------------------

(2)CHATGPT :

What's ABNF grammar in an IRC protocol ?

ChatGPT said:

ABNF (Augmented Backus-Naur Form) is a formal syntax notation used to describe the grammar of communication protocols and data formats. In the context of the IRC (Internet Relay Chat) protocol, ABNF grammar defines the structure of messages exchanged between IRC clients and servers, as specified in RFC 1459 and subsequent related documents.

Key Points About ABNF in IRC
Structure of IRC Messages: An IRC message generally consists of:

An optional prefix.
A command.
Zero or more parameters.
Example ABNF representation:

abnf
Copy code
message   = [ ":" prefix SPACE ] command [ params ] crlf
prefix    = servername / ( nickname [ "!" user ] [ "@" host ] )
command   = 1*letter / 3digit
params    = *14( SPACE middle ) [ SPACE ":" trailing ]
crlf      = CR LF
Common Components:

prefix: Identifies the source of the message (e.g., a nickname, server, or user).
command: Specifies the action, such as PRIVMSG (send a private message) or JOIN (join a channel).
params: Includes arguments for the command, separated by spaces. If the parameter starts with :, it can include spaces as part of the argument.
Examples: Using the ABNF definitions:

Message from a user to join a channel:
ruby
Copy code
:nickname!user@host JOIN #channel
Private message:
ruby
Copy code
:nickname!user@host PRIVMSG #channel :Hello, world!
Why ABNF?

ABNF is machine-readable and precise, making it ideal for protocol specifications.
It provides a consistent way to define complex message formats.
If you'd like to dive deeper into specific ABNF definitions in the IRC protocol or examples of how commands are structured, let me know!

