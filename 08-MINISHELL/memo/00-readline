
La commande readline permet de lire sur l'entrée standard et renvoie un char* (command_line)
qui contient la lecture.
Cette fonction est à inclure dans une boucle qui s'exécutera jusqu'à ce qu'elle retourne un
NULL ou par la commande exit. Ce retour est obtenu par CTRL D (EOF).

La fonction readline leak.

Le contenu du fichier readline.supp permet de ne pas faire apparaître les leaks en rajouttant
le flag (valgrind --suppressions=chemin/vers/votre_fichier.supp)

La fonction add_history stocke dans un fichier les commandes passées dans le terminal.
Cette fonction doit être free par la fonction clear_history(). 

Si la ligne de commande prend la valeur exit, les free (et close), le clear_history sont
effectués.

La structure command_line prend le retour de la fonction parse_command_line.

Si la valeur exit_code est différente de 0, la fonction error_handling est appelée. Les free
(et close) sont effectués et un message d'erreur est affiché.

Si la valeur exit_code est égale à 0, les free (et close) sont effectués.

-----------------------------------------------------------------------------------------------

La fonction main (fichier minishell.c) :

	- un pointeur sur une variable de type char * est déclaré et initialisé à NULL.
	Cette variable est destiné à récupérer le retour de la fonction readline. 
	- un pointeur sur une structure de type t_envp_struct est déclaré et initialisé à
	NULL. Cette structure contiendra une copie de l'environnement de bash.
	- une variable de type int est déclarée : elle est destiné à contenir l'exit_code.
	- la fonction get_envp est appelée : elle va faire une copie de l'environnement de
	bash.
	- la fonction get_and_execute_command_line est appelée pour lire la ligne de commande,
	la parser, procéder aux expands, et l'exécuter.
	- la structure envp_struct est free.
	- la fonction retourne l'exit_code.

-----------------------------------------------------------------------------------------------

La fonction get_envp() (get_and_free_envp.c) appelle en boucle la fonction add_line jusqu'à
avoir lu l'envp dans sa totalité.

-----------------------------------------------------------------------------------------------

La fonction add_line() (fichier get_and_free_envp.c) ;
	- crée et initialise un nouvel élément de type envp_struct,
	- lit la ligne de l'env qui lui a été envoyée, cherche le =, copie le nom de la variable
	dans name, vérifie la présence d'un signe égal, copie la valeur éventuelle dans value.
	- ajoute le nouvel élément dans la liste chaînée.

-----------------------------------------------------------------------------------------------

La fonction get_and_execute_command_line() (fichier minishell.c) lit en boucle le retour de
readline, parse, execute, free et retourne si builtin exit appelé ou si CTRL D.
	- la fonction appelle readline_and_get_signals qui assigne line et lit les signaux,
	- si readline_and_get_signals retourne NULL (CTRL D), la boucle est interrompue.
	Le pogramme est quitté.
	- previous_exit_code prend la valeur de exit_code (cas du CTRL C).
	- si line n'est pas à NULL :
		- l'historique est initialisé,
		- le pointeur command_line est assigné au retour de la fonction
		parse_command_line (à savoir la fonction qui lit la ligne de command et 
		assigne les arguments et redirections bruts et expanded),
		- la fonction init_and_execute() est appellée. Elle vérifie la validité des
		arguments et des redirections et les prépare pour l'exécution qui exécute
		les instructions,
		- la fonction save_exit_code_and_free_lists() est appelée. Cette dernière
		permet notamment de sauvegarder le dernier exit_code avant le free de la
		structure command_line. La globale g_sign est remise à zéro (sécurité?).
		- le double pointeur sur line est remis à NULL.

-----------------------------------------------------------------------------------------------

La fonction readline_and_get_signals() (fichier minishell.c) :
	- appelle la fonction signals avec l'argument 0 (qui correspond à la situation readline),
	- appelle readline qui retourne son résultat dans line,
	- vérifie line :
		- si line est à NULL (EOF) par CTRL D, la fonction affiche exit, free,
		clear_history et quitte en provoquant un break de la boucle dans
		la fonction get_and_execute_command_line qui génère un retour avec un exit_code
		à 0,
		- sinon la valeur de la globale g_sign est vérifiée. Si elle est différente de 0
		(cas du CTRL C dans readline), elle permet de mettre le previous_exit_code à 130
		dans la fonction get_and_execute_command_line en cas de saisie de $? à l'appel
		suivant de readline. La globale g_sign est remise à zéro.

-----------------------------------------------------------------------------------------------		

La fonction init_and_execute() (fichier minishell.c):
	- initialise la structure exec_struct,
	- assigne les pointeurs contenus dans la structure exec_struct,
	- si le parsing et l'expand se sont correctement exécutés, la fonction
	build_exec_struct() ext appelée. Cette fonction traite les heredoc, vérifie les
	redirections et les arguments.
	- si l'exit_code est différent de 130 (cas d'un CTRL C dans des heredocs), la fonction
	signals() (avec un argument à 2 pour l'exécution) est appelée, puis la fonction
	execution(), et l'envp_struct est mis à jour pour le prochain appel de la fonction.

-----------------------------------------------------------------------------------------------		


