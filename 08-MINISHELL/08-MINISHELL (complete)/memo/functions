https://web.mit.edu/gnu/doc/html/rlman_2.html

Readline

-----------------------------------------------------------------------------------------------

Ce chapitre décrit l'interface entre la librairie GNU Readline (readline/readline.h) et les
autres programmes. Il traite de la complétion, de l'édition de lignes, de la manipulation
interactive de l'historique.

-----------------------------------------------------------------------------------------------

Comportement de base :

De nombreux programmes proposent une interface de ligne de commande, tel que mail, ftp, sh.
Pour de tels programmes, le comportement par défaut de Readline est suffisant.
Cette section décrit comment utiliser Readline de la façon la plus simple possible, peut-être
en remplacement de l'appel à gets() ou fgets().

La fonction readline() affiche un prompt (une invite) et ensuite lit et retourne une seule
ligne de texte envoyée par l'utilisateur. La ligne retournée par readline() est allouée avec
malloc(). Après l'avoir traitée, la ligne devra être free.

Dans le référentiel ANSI C, la déclaration de la fonction readline() est :
char *readline(char *prompt).

On pourrait avoir :
char *line = readline("Enter a line: ")
afin de lire une ligne de texte envoyée par l'utilisateur.
La ligne renvoyée est débarrassée de la dernière nouvelle ligne (l'invite ?), de sorte que seul
le texte est conservé.
Si readline() trouve un EOF lors de la lecture de la ligne, et que la ligne est vide
jusque là, alors un pointeur (char *) à NULL est renvoyé. Sinon, la ligne est terminée comme si
une nouvelle ligne avait été saisie.

Si vous voulez que l'utilisateur puisse rappeler la ligne plus tard, vous devez faire appel à
la fonction add_history() pour sauvegarder la ligne dans un historique.
Pour accéder à tous les détails de la librairie GNU History (readline/history.h), voir le
maiuel associé.



-----------------------------------------------------------------------------------------------

Fonctions spéciales (custom functions) :

Readline() propose de nombreuses fonctions pour manipuler la ligne de texte, mais il est
impossible de prévoir les besoins de tous les programmes. Cette section décrit les différentes
fonctions et variables definies dans la librairie de readline() qui permettent à un programme
utilisateur d'ajouter des fonctionnalités personnalisées à Readline.
 
Le type de fonction :


Ecrire une nouvelle fonction :

Pour écrire de nouvelles fonctions pour readline(), vous devez connaître les conventions
d'appel des fonctions invoquées par le clavier et les noms des variables qui décrivent l'état
actuel de la ligne lue jusqu'à présent. 

La séquence d'appel à une commande foo ressemble à ceci :

foo(int count, int key)

où count est l'argument numérique (ou 1 par défaut) et où key est la touche clavier qui
invoque cette fonction.

C'est à la fonction de décider ce qu'il convient de faire avec l'argument numérique. Certaines
fonctions l'utilisent comme un itérateur (repeat count), d'autres comme un drapeau (flag), et
d'autres encore pour choisir un autre comportement (rafraîchir la ligne en cours plutôt que
l'écran, par exemple). D'autres encore choisissent de l'ignorer. En général, si une fonction
utilise l'argument numérique comme itérateur, elle doit pouvoir faire quelque chose d'utile
avec les arguments négatifs et positifs. Au minimum, elle doit savoir qu'on peut lui passer
un argument négatif.

Variable : char *rl_line_buffer

Il s'agit de la ligne recueillie jusqu'à présent. Vous pouvez modifier le contenu de cette
ligne, mais consultez la section Autoriser l'annulation.

-----------------------------------------------------------------------------------------------

Fonctions pratiques de readline()


Nommer une fonction :


Sélectionner une map de touches clavier :


Touches clavier de liaisons :


Associer des noms de fonctions et des liaisons :


Permettre d'annuler :


Réaffichage (redisplay) :

	- fonction int rl_redisplay() :
	change l'affichage à l'écran par le contenu courant de rl_line_buffer





