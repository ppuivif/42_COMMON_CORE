CPP

-----------------------------------------------------------------------------------------------

Vidéo 42 - Days02 - Intro

Le polymorphisme ad-hoc ou surcharge de fonction : particularité de CPP permettant d'avoir
plusieurs définitions de fonction ayant le même nom et prenant des paramètres différents.

La surcharge d'opérateur : cette notion découle directement de la précédente qui permettra
d'étendre la syntaxe et la sémantique de CPP en définissant de nouveaux opérateurs. En pratique
cela permet de surcharger la fonction qui correspond à un opérateur, en tout cas la plupart des
opérateurs de CPP, pour rajoutter un "sucre" syntaxique facilitant la lecture.

La forme canonique d'une classe : principe qui permet de déclarer des classes toujours de la
même façon avec des fonctions membres, de constructeurs, ... qui sont toujours présents et qui
permettent une utilisation unifiée de toutes les classes.
	
-----------------------------------------------------------------------------------------------

Vidéo 42 - Days02 - ad-hoc polymorphism

Principe en CPP permettant de définir plusieurs fonctions ayant le même nom mais prenant des
paramètres différents (inexistant en C).

Exemple de déclaration de classe :

#ifndef SAMPLE_CLASS_H
# define SAMPLE_CLASS_H

class Sample{

public:

	Sample(void);
	~Sample(void);

//4 surcharges de fonction bar
	void	bar(char const c)const;
	void	bar(int const n)const;
	void	bar(float const z)const;
	void	bar(Sample const & i)const;
};

#endif;

NB : la surcharge fonctionne sur n'importe quelle fonction (pas seulement les fonctions
membres)

La surcharge permet de spécialiser une fonction en fonction de ses entrées.

Exemple d'implémentation :

#include <iostream>
#include "Sample.class.hpp"

Sample::Sample(void){

	std::cout << "Constructeur called" << std::endl;
	return ;
}

Sample::bar(char const c)const{

	std::cout << "Member function bar called with char overload : " << c << std::endl;
	return ;
} 

Sample::bar(int const n)const{

	std::cout << "Member function bar called with int overload : " << n << std::endl;
	return ;
}

Sample::bar(float const z)const{

	std::cout << "Member function bar called with float overload : " << z << std::endl;
	return ;
} 

Sample::bar(Sample const & i)const{

	std::cout << "Member function bar called with Sample class overload : " << std::endl;
	return ;
} 

Sample::~Sample(void){

	std::cout << "Destructeur called" << std::endl;
	return ;
}

-----------------------------------------------------------------------------------------------

Vidéo 42 - Days02 - Operator overload

CPP est un language qui propose une syntaxe afin de pouvoir étendre les opérateurs de CPP,
pouvoir ajouter de la sémantique et de la syntaxe au language pour pouvoir l'adapter aux
besoins.

Vocabulaire :

"1 + 1" : notation infixe car l'opérateur '+' se situe entre les 2 opérandes

Mais il existe d'autres notations :

"+ 1 1" : notation préfixe (ou notation fonctionnelle) car si on l'écrit "+ (1, 1)", cela
ressemble beaucoup à la définition d'une fonction. Cette notation est celle qui devra permettre
de comprendre la surcharge d'opérateur en CPP. 

"1 1 +" : notation postfixe
Cette notation est en particulier celle que l'on pourra utiliser dans le cadre de calculs sur
piles (je push un 1, je push un 1, puis j'additionne).

La notation fonctionnelle :
C'est une notation qui pourrait être utilisés dans le cadre de la définition d'une fonction
membre.
On pourrait imaginer la notation suivante :
1.+(1)
1 : on aurait dans ce cas une instance quelconque (ici 1) sur laquelle on ferait appel à la
fonction membre '+' et à laquelle on ferait passer un paramètre 1.

Exemple de déclaration :

#include <iostream>

#ifndef INTEGER_CLASS_H
# define INTEGER_CLASS_H

class Integer{

public:

	Integer(int const n);
	~Sample(void);

	int	getValue(void) const;
	
//2 surcharges d'opérateur :
	Integer & operator=(Integer const & rhs);//operator est un mot clé spécial qui va
		permettre de faire d'une simple déclaration de fonction membre de la classe
		une surcharge d'opérateur. Il suffit ensuite de spécifier de quel opérateur
		on parle entre le mot clé operator et la parenthèse ouvrante des paramètres.
	Integer & operator+(Integer const & rhs) const;
	
private:
	int	_n;
};

std::ostream & operator<<(std::ostream & o, Integer const & rhs);

#endif;

Les opérateurs : on peut avoir des opérateurs unaires, binaires, ternaires (ces derniers ne
sont pas surchargeables). Le nombre de paramètres va être fonction du type d'opérateur
(un pour unaire, deux pour binaire).
L'opérateur d'assignation '=' est un opérateur binaire car à sa droite, il y a ce que je
souhaite assigner, et à sa gauche ce dans quoi je veux assigner.
L'opérateur d'assignation '+' est lui aussi un opérateur binaire car à sa droite et à sa
gauche, il y a deux opérandes.

En terme de notation, on a deux notations possibles (préfixe classique (fonctionnelle)
et notation type fonction membre).

La notation de déclaration d'une fonction membre laisse penser qu'on lui envoie un seul
paramètre : Integer & operator=(Integer const & rhs);
En réalité, il y en a bien deux car il y a aussi le paramètre caché qui représente
l'instance courante.

NB : la pré et la post-incrémentation sont des opérateurs unaires. Avec ce type de surcharge,
il n'y a aucun paramètre visible car seul paramètre caché (le this) suffit.

NB : rhs signifie Right-Hand Side (le paramètre caché This est le Left-Hand Side).

L'opérateur d'assignation :
Il a pour sémantique de mettre à jour la valeur de l'entier qui est dans
l'instance courante à la valeur de l'entier qui est passé en paramètre. Donc l'instance
courante va être modifiée. La fonction membre d'assignation n'est donc pas const.

La surcharge de l'opérateur '+' :
Même principe, mais la fonction ne modifie ni l'instance courante ni l'autre opérande (la
valeur passée en paramètre). Donc cette fonction est const.

Les valeurs retournées :
Dans le cas de la fonction d'assignation, le retour de la fonction est une référence sur une
classe Integer. C'est tout simplement l'instance courante qui sera renvoyée.
Pourquoi ?
En C et CPP, il est possible de chaîner des assignations : a = b = c = d;
Un renvoi de type void ne permettrait pas cet chaînage d'assignation. Le chaînage s'arrêterait
à la première assignation.

Pour l'opérateur '+', l'instance courante n'est pas modifiée.
Le fait d'écrire 1 + 2 + 3 + 4; ne nécessite pas de calculer 3 + 4 pour calculer 1 + 2 (le
parenthésage importe peu). On va donc se contenter de renvoyer une copie du résultat.

Exemple d'implémentation :

#include <iostream>
#include "Integer.class.hpp"

Integer::Integer(int const n) : -_n(n){

	std::cout << "Constructor called with value" << n << std::endl;
	return ;
}


Integer::getValue(void)const{//getter renvoie une copie de la valeur
	return (this->_n);
}

Integer	& Integer::operator=(Integer const & rhs){

	std::cout << "Assignation operator called from " << this->_n;
	std::cout << " to " << rhs.getValue() << std:: endl;
	
	this->_n = rhs.getValue();

	return *this;//déréfenrecement du pointeur this
}

Integer	Integer::operator+(Integer const & rhs)const{
	std::cout << "Addition operator called with " << this->_n;
	std::cout << " and " << rhs.getValue() << std:: endl;
	
	return Integer(this->_n + rhs.getValue());//le résultat de l'addition est utilisé
		pour créer une nouvelle instance de la classe Integer. Une copie de cette
		instance est renvoyée, ce qui mobilise un peu plus la mémoire, mais sans
		autre possibilité de faire plus proprement.
}

Integer::~Integer(void){

	std::cout << "Destructor called << std::endl;
	return ;

10'05"

Jusqu'à présent, les cas présentés reposaient sur une instance courante qui permettait de
faire l'opération.
Le dernier cas est un peu plus compliqué : la surcharge d'un opérateur de redirection de flux
(vers la gauche : <<).
Ostream est une classe qui a été codée sans tenir compte d'une possibilité de surcharge. Elle
ne peut être modifiée/remplacée par une classe Integer (ou autre). On ne peut pas utiliser la
syntaxe des fonctions membres pour faire une surcharge de "<<".
On ne pas va donc pas faire une surcharge de fonction membre, mais une simple surcharge de
fonction.

La fonction prend en premier paramètre une instance de classe ostream (en particulier une
référence sur l'instance, par exemple cout) et en deuxième paramètre une instance de la
classe Integer pour pouvoir faire l'affichage. On renvoie une référence sur une instance de
classe ostream pour pouvoir chaîner les redirections et faire plusieurs affichages.

std::ostream & operator<<(std::ostream & o, Integer const & rhs){

	o << rhs.getValue();// on va utiliser le flux de sortie 'o' vers lequel on va
		rediriger quelques chose, à savoir un entier (_n).
	return o;
}

Un exemple de main :

#include <iostream>
#include "Integer.class.hpp"

int main(){

	Integer	x(30);
	Integer	y(10);
	Integer	z(0);
	
	std::cout << "Value of x : " << x << std::endl;
	std::cout << "Value of y : " << y << std::endl;
	y = Integer(12);
	std::cout << "Value of y : " << y << std::endl;
	
	std::cout << "Value of z : " << z << std::endl;
	z = x + y;
	std::cout << "Value of z : " << z << std::endl;
	
	return 0;
}	
-----------------------------------------------------------------------------------------------

Vidéo 42 - Days02 - Canonical form

La forme canonique (de Coplien) est plutôt une bonne pratique qu'un véritable notion de CPP.
C'est une façon de construire des classes de base afin de s'assurer une interface raisonnable
et surtout identique sur tout son travail.

Exemple de déclaration :

#ifndef SAMPLE_CLASS_H
#define SAMPLE_CLASS_H

#include <iostream>

class	Sample{

public:
	Sample(void);//constructeur
	Sample(int const n);//constructeur par paramètre
	Sample(Sample const & src);//constructeur par copie
	~Sample(void);//destructeur
	
	Sample & operator=(Sample const & rhs);//surcharge d'opérateur
	
	int	getFoo(void) const;//accesseur

private:

	int _foo;
};

std::ostream & operator<<(std::ostream & o, Sample const & t);

#endif

Une classe est sous forme canonique lorsqu'elle contiendra au moins :
 - un constructeur par défaut,
 - un constructeur par copie, i.e. un constructeur prenant en paramètre une instance de la
 classe qui est en train d'être déclarée afin de pouvoir réaliser une copie de cette classe.
 - un opérateur d'assignation '=' qui permettra de faire une autre assignation à partir d'une
 instance cette classe. On voit que le comportement est assez proche de celui du constructeur
 par copie sachant qu'avec le constructeur par copie une nouvelle instance est créée, alors
 qu'avec l'opérateur d'assignation, on a une mise à jour de l'instance courante.
 - un destructeur (éventuellement virtuel).
 
Exemple d'implémentation :

#include <iostream>
#include "SampleClass.hpp"

Sample::Sample(void) : _foo(0){

	std::cout << "Default constructor called" << std::endl;
	
	return;
}

Sample::Sample(int const n) : _foo(n){

	std::cout << "Parametric constructor called" << std::endl;

	return;
}

Sample::Sample(Sample const & src){

	std::cout << "Copy constructor called" << std::endl;
	*this = src;
	
	return;
}

Sample::~Sample(void){

	std::cout << "Destructor called" << std::endl;
	
	return;
}

int	Sample::getFoo(void) const{//accesseur non requis par la forme canonique mais
					souhaitable

	return this->_foo;
}

Sample&	Sample::operator=(Sample const &rhs){

	std::cout << "Assignment operator called" << std::endl;
	
	if(this != &rhs)
		this->_foo = rhs.getFoo();

	return *this;
}

std::ostream &	operator<<(std::ostream & o, Sample const & t){//surcharge de redirection
							non requise pour la forme canonique
							mais assez pratique

	o << "The value of _foo is : " << t.getFoo();

	return o;
}

NB : il peut être intéressant d'avoir une fonction de "serialisation" vers une string pour le
débuguage

Exemple de main :

#include <iostream>
#include "SampleClass.hpp"

int main(){

	Sample	instance1;//appel du constructeur par défaut
	Sample	instance2(42);//appel du constructeur par paramètre
	Sample	instance3(instance1);//appel du constructeur par copie
	
	std::cout << instance1 << std::endl;
	std::cout << instance2 << std::endl;
	std::cout << instance3 << std::endl;
	
	instance3 = instance2;//assignation
	std::cout << instance3 << std::endl;
	
	return 0;	
}

NB : un constructeur par défaut peut ne pas être utile, et dans ce cas, il peut être possible
de le déclarer en private.

-----------------------------------------------------------------------------------------------

Vidéo 42 - Days02 - Conclusion

-----------------------------------------------------------------------------------------------

