Const and ref

-----------------------------------------------------------------------------------------------

If I declare :

	std::string getName(void) const;

It means that the function of the class does not modify the state of the object, and so does
not modify any member variable of the class (except those marked as mutable).

example of declaration :

class MyClass {
	private:
	    std::string _name;
	public:
	    std::string getName(void) const;
};

example of definition :

std::string MyClass::getname(void) const
{
        return _name; // This method doesn't modify `name`.
}

In this case, if I want to modify a variable inside getName(), the compiler will give an error.

-----------------------------------------------------------------------------------------------

If I declare :

	std::string const getName(void);

It means that the return value of the function is a const std::string, and that the caller
cannot modify the returned string.

example of declaration :

class MyClass {
	public:
	    std::string const getName(void);
};

example of definition :

std::string const getName(void)
{
    return "Immutable Name"; // The returned string cannot be modified by the caller.
}

example of instantiation :

MyClass obj;
const std::string name = obj.getname();
name = "New Name"; // Compiler error because 'name' is const.

-----------------------------------------------------------------------------------------------

If I declare :

	std::string const getName(std::string const name);

It means that the parameter 'name' cannot be modified inside the function (it is treated as
read-only).
But this parameter could be modify outside the function. The caller could have passed a const or
not const std::string.

example of declaration :

class MyClass {
	public:
	    std::string const getName(std::string const name);
};

example of definition :

std::string getName(std::string const name)
{
    // name = "new value"; // Compiler error! name is const inside the function.
    return name;
}

example of instantiation :

std::string myName = "John";
getName(myName); // Valid, even though myName is not const.

const std::string constName = "Jane";
getName(constName); // Valid, even with a const string.

When Would You Use This?

Using const for parameters like std::string const name is a good practice if:

	- You do not want to accidentally modify the parameter inside the function.
	- It ensures clarity that this parameter is read-only for the function implementation.


-----------------------------------------------------------------------------------------------

If I instantiate :

int main()
{
    const std::string constName = "Read-Only Name";
    display(constName); // Valid, no issue here.
    return 0;
}


And if I have previously define :

void display(std::string name) //name is not defined as const
{
    std::cout << name << std::endl;
}

There won't be any problem because name is passed as value and is manipulate in the display
function as a copy without affecting the original variable.

-----------------------------------------------------------------------------------------------

But know, if name is passed by reference, const becomes important.
 

