CPP

-----------------------------------------------------------------------------------------------

Vidéo 42 - Days04 - Sub-typing polymorphism

Approfondir le concept d'héritage et aborder le concept de polymorphisme par sous-typage

Hériter d'une classe Character signifie que l'on est un Character.
Un Warrior qui hérite d'un Character est un Character.
Le Character a une manière de dire bonjour, le Warrior peut avoir sa propre façon de dire
bonjour (dans ce cas, on override (redéfinit) la fonction).

Exemple de déclaration :

#include <string>
#include <iostream>

class Character
{
	public:
		void	sayHello(std::string const &target);
};

class Warrior : public Character
{
	public:
		void	sayHello(std::string const &target);
};

class Cat //qui n'a rien à voir avec le Character
{

};

Exemple d'implémentation :

void	Character::sayHello(std::string const & target)
{
	std::cout << "Hello " << target << " !" << std::endl;	
}

void	Warrior::sayHello(std::string const & target)
{
	std::cout << "Fuck off " << target << ", I don't like you !" << std::endl;	
}

On va utiliser le fait qu'un Warrior soit un Chconst Ice &rhsaracter pour écrire les choses suivantes :

Exemple d'instanciation :

int main()
{
	//This is OK, obviously, Warrior IS a Warrior
	Warrior	*a = new Warrior();

	//This is also OK because Warrior IS a Character
	Character	*b = new Warrior();
	
	//This would not be OK because Character IS NOT a Warrior
	//(Although they ARE related, and Warrior IS a Character, the reverse is untrue)
	//Warrior	*c = new Character();

	//This would NOT be ok either because Cat is NOT a Character
	//(They are not even related)
	//Character	*d = new Cat();
	
	a->sayHello("students"); // va dire bonjour à la manière d'un Warrior
	
	b->sayHello("students"); // va dire bonjour à la manière d'un Character car le
				compilateur a compris que l'on créait un Character
}

Pour que l'instance b se comporte comme un Warrior on va utiliser le mot clé virtual devant la
déclaration de la fonction sayHello.

Exemple de déclaration :

#include <string>
#include <iostream>

class Character
{
	public:
		virtual void	sayHello(std::string const &target);
};

class Warrior : public Character
{
	public:
		void	sayHello(std::string const &target);
};

Initialement, on avait une résolution statique de l'appel de fonction car le compilateur
savait déjà quelle fonction appeler car il utilise le type de l'objet.

Dans le dernier cas, le linkage est dynamique et non plus statique.
Selon ce que l'utilisateur saisit à l'exécution (Character, Warrior, Mage, ...), le
compilateur constatant que la fonction membre est dynamique, il va regarder quel est le type
réel de l'objet.

Une fonction membre virtuelle, dont la résolution est dynamique, est désignée comme étant une
méthode.

-----------------------------------------------------------------------------------------------

Vidéo 42 - Days04 - Abstract classes and interfaces

Un nouveau concept : la méthode pure

Exemple de déclaration :

#include <string>
#include <iostream>

class ACharacter
{
	private :
		std::string 	_name;
	public:
		virtual void	attack(std::string const & target) = 0; //le "= 0" définit la
							méthode comme une méthode pure
		void		sayHello(std::string const &target);
};

class Warrior : public ACharacter
{
	public:
		virtual void	attack(std::string const & target);
};

Exemple d'implémentation :

void	ACharacter::sayHello(std::string const &target)
{
	std::cout << "Hello " << target << " !" << std::endl;
}

void	Warrior::attack(std::string const & target)
{
	std::cout << "*attacks " << target << " with a sword*" << std::endl;
};

Exemple d'instanciation :

int main()
{
	ACharacter *a = new Warrior();
	
	//This would NOT be ok because ACharacter is abstract
	//ACharacter *b = new ACharacter();
	
	a->sayHello("students");//possible car 'a' a le comportement d'un Warrior
	a->attack("roger");//possible car 'a' a le comportement d'un Warrior
}

On ne peut pas implémenter une méthode pure.
On ne peut donc pas instancier la classe : elle est dite abstraite. Par convention, pour
la déclarer, on va préfixer son nom d'un A (A comme abstraite).

Si une classe hérite d'une classe abstraite, elle va hériter de son comportement, et en
particulier de l'attaque dans l'exemple précédent. Néanmoins, elle ne pourra pas mettre
en oeuvre ce comportement, attaquer, par elle-même.

Certains comportements ne sont pas définis, mais d'autres peuvent l'être.

C'est une manière de factoriser certains comportements. C'est une manière de dire ques les
classes fille devront avoir tel ou tel comportement, même si la classe mère ne l'a pas.

Pour pouvoir être instanciée, une classe qui hérite d'une classe abstraite va devoir
implémenter les comportements déclarés comme abstraits dans la classe parent.


3'15 : interfaces

Nous avions précédemment un comportement abstrait (attack) et un comportemenr concret
(sayHello) dans la classe ACharacter.
La classe peut ne comporter que des comportements abstraits. En faisant cela, on crée une
interface.
Par convention, pour déclarer une interface, on va préfixer le nom de la classe d'un I
(I comme interface).

Exemple de déclaration :

class ICoffeeMaker
{
	public:
		virtual void	fillWaterTank(IWaterSource * src) = 0;
		virtual	ICoffee *makeCoffee(std::string const & type) = 0;
};

L'interface n'ajoute pas seulement des méthodes pures, elle n'a pas non plus d'attributs.
L'interface a été pensée comme une manière d'établir un contrat pour les classes qui en
héritent, c'est une manière de définir un comportement.
La déclaration précédente ne factorise aucun comportement réel de la machine à café mais tout
objet concret qui hérite de la classe ICoffeeMaker aura forcément ces comportements (remplir
le réservoir d'eau et faire du café, sans toutefois savoir comment remplir le réservoir ni
comment faire le café).

Ces interfaces sont en particulier très utiles pour développer en équipe. Une fois que la
manière d'utiliser les fonctions est définie, chaque développeur implémente les fonctions
à sa façon.

-----------------------------------------------------------------------------------------------







