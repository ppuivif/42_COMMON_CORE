CPP

-----------------------------------------------------------------------------------------------

Pour initialiser une variable dans le constructeur :

déclaration dans header .hpp
	Zombie(std::string name);

implémentation dans .cpp

	Zombie::Zombie(std::string name) : _name(name)
	{
		return ;
	}
	
-----------------------------------------------------------------------------------------------

Définition d'une macro de mise en forme du texte du terminal

#ifndef RED //header guard
		Ensures that RED is only defined once, preventing redefinition errors
		if this code is included multiple times in a project
# define RED "\033[31m" //ANSI escape code for red text
# endif
#ifndef BOLD
# define BOLD "\033[1m"
# endif
#ifndef NORMAL
# define NORMAL "\033[0m"
# endif

-----------------------------------------------------------------------------------------------

Protection d'allocation dynamique (à priori pas nécessaire)

	Zombie		*horde;
	
	zombieHorde = new(std::nothrow) Zombie[5];
	if (!zombieHorde)
		std::cout << "Error : allocation failed" << std::endl;
	
-----------------------------------------------------------------------------------------------

Atoi :

int	toNumber(std::string str)
{
	int					num;
	std::istringstream	iss(str);

	if (!(iss >> num) || num < 0)
		return (-1);
	else
		return (num);
}

std::istringstream est une classe. Elle fait partie de la bibliothèque standard C++ (dans
l'en-tête <sstream>). Cette classe permet de traiter une chaîne de caractères comme si elle
était un flux d'entrée, ce qui est utile pour extraire des données d'une chaîne, un peu comme
on le ferait avec std::cin pour la console.

iss est une instance de la classe std::istringstream. On appelle aussi cela un objet. Cet objet
est initialisé avec le contenu de la chaîne str, ce qui permet de lire et d'extraire des
données à partir de cette chaîne.

-----------------------------------------------------------------------------------------------

Itoa

std::string	toString(int nb)
{
	std::ostringstream	oss;

	oss << nb;
	return (oss.str());
}

Pas de protections à prévoir.

-----------------------------------------------------------------------------------------------

Fonction de gestion de signal CTRL C pour sortir proprement :

void	signalHandler(int signal)
{
	if (signal == SIGINT)
	{
		std::cerr << std::endl << RED << "Warning : program interrupted by CTRL C" \
		<< NORMAL << std::endl;
		exit (EXIT_FAILURE);
	}		
}

-----------------------------------------------------------------------------------------------

Fonction de gestion de l'input de l'utilisateur et gestion de CRL D (EOF) : permet d'éviter une
boucle infiniie d'affichage

std::string getName(void)
{
	std::string	input;
	
	std::cout << BOLD << "Enter \'zombieName\' : " << NORMAL;
	std::cin >> input;
	if (std::cin.eof())
		exit(EXIT_FAILURE);
	std::cout << std::endl;
	return (input);
}

-----------------------------------------------------------------------------------------------

Fonction d'invite à la saisie et de récupération de l'input :

#include <limits> //to use numeric_limits

std::string getName(void)
{
	std::string	input;

/*	std::cin.clear(); //Resets the state of std::cin, clearing any error flags that may
				have been set.
	std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');*/Discards any
		characters currently in the input buffer up to the next newline (\n).
		This ensures that no leftover characters interfere with your input.
		Necessary if previous input with cin
		Not necessary if previous input with getline
	while (input.empty())
	{
		std::cout << BOLD << "Enter \'zombieName\' : " << NORMAL;
		std::getline(std::cin, input);
		if (std::cin.eof())
			exit(EXIT_FAILURE); // or return a value for example to return in the
						main function
		if (input.empty())
			std::cout << RED << "Enter a valid input (non empty) : " << NORMAL \
			<< std::endl;
	}
	std::cout << std::endl;
	return (input);
}

-----------------------------------------------------------------------------------------------

Pourquoi créer une fonction membre statique : 

	- une fonction membre statique n'opère pas sur une instance spécifique de la classe car
	elle appartient directement à la classe :
		- elles n'ont pas de pointeur this,
		- elles ne peuvent accéder qu'aux variables et fonctions membre statiques, qui
		sont elles aussi partagés entre toutes les instances de la classe,
		- elle peut être appelée en utilisant le nom de la classe, sans avoir besoin
		d'une instance.

	- ce type de fonction est donc souvent utilisé pour implémenter des fonctions
	utilitaires liées à la classe mais qui ne nécessitent pas de données spécifiques à une
	instance.
		e.g. :
			- déclaration :
				static Fixed	min(Fixed &f1, Fixed &f2);
			- définition :
				Fixed	Fixed::min(Fixed &f1, Fixed &f2)
				{
					if (f1 <= f2)
						return (f1);
					return (f2);
				}
			- appel de fonction :
				Fixed f1(10.1f); 
				Fixed f2(10.5f);
				Fixed result = Fixed::min(f1, f2);
				
	- ce type de fonction est utilisé pour des fonctions qui ont un fonctionnement global
	tout een étant associée à une classe.
		e.g. : afficher un message associé à une fonction de log. Dans ce cas,
		l'affichage du message est logiquement associé à la classe mais ne dépend pas
		d'une instance.

	- les fonctions statiques sont idéales pour fonctionner avec des variables / fonctions
	membres	statiques.
	
	- les fonctions statiques sont souvent utilisées pour implémenter le design pattern
	factory method afin de créer des objets. A développer.
	
	- en terme de peformance, les fonctions statiques offrent un léger avantage car elles
	n'ont pas besoin de pointeur this (ni de virtual dispatch, à développer).

Remarques :
	- les fonctions  statiques n'ont pas accès aux variables d'instance ni aux fonctions
	membres non-statiques.
	- les fonctions statiques ne peuvent pas être virtuelles, car elles ne sont pas liées
	à un objet spécifique et ne supportent donc pas le polymorphisme (??? à confirmer car
	polymorphisme utilisé pour les fonctions min et max appliquées aux Fixed).

En résumé :
	L'intérêt principal de créer une fonction membre statique est d'encapsuler une logique
	pertinente pour la classe dans son ensemble, plutôt que pour une instance spécifique.
	Cela permet une meilleure organisation, un meilleur regroupement logique, et parfois
	une meilleure efficacité.
	
-----------------------------------------------------------------------------------------------

