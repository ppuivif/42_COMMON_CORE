CPP

-----------------------------------------------------------------------------------------------
Vidéo 42 : introduction


Namespace : "sac"
permet de réunir au sein d'un même ensemble toutes les notions qui présentent un rapport
sémantique entre elles.

This : pointeur d'instance


-----------------------------------------------------------------------------------------------

Vidéo 42 : les namespaces

NB :
Un fichier est une unité de compilation.

Namespace : "sac"
permet de regrouper au sein d'un même ensemble (le namespace) toutes les notions (symboles,
fonctions) qui présentent un rapport sémantique entre elles.

En language C, les fichiers jouent ce rôle. Par exemple un fichier permet de manipuler des listes.
La manipulation des listes est décrite dans ce fichier. Souvent, lors de manipulations complexes,
les fichiers deviennent rapidement volumineux (de nombreux symboles, de nombreuses fonctions),
d'où la nécessité de découper en plusieurs fichiers avec toutefois la possibilité de rassembler
les symboles, non pas au niveau d'un fichier, mais de façon plus globale qui peut s'étendre sur
plusieurs fichiers. L'idée est alors de donner un nom à ce regroupement.
C'est l'idée des namespaces. 

Premier exemple :

#include <stdio.h>

int	gl_var = 1;// déclaration d'une variable globale de type entier initialisée à 1
int	f(void){return 2;}// definition d'une fonction f qui ne prend pas de paramètres, qui
				renvoie un entier et qui retourne la constante 2

namespace	Foo{// permet de rassembler des symboles que je juge liés sémantiquement

	int	gl_var = 3;
	int	f(void){return 4;}

}

namespace	Bar{

	int	gl_var = 5;
	int	f(void){return 6;}

}

namespace	Muf = Bar;// aliasing de namespace permettant d'imbriquer des namespaces les uns
				dans les autres et de simplifier la syntaxe 

//avec plusieurs namespaces portant des noms différents, on peut avoir des symboles qui ont le
même nom sans générer de conflits.

int	main(void){

	printf("gl_var: [%d]\n", gl_var);
	printf("f(): [%d]\n\n", f());

	printf("Foo::gl_var: [%d]\n", Foo::gl_var);// :: opérateur de resolution de portée
	printf("Foo::f(): [%d]\n\n", Foo::f());
	
	printf("Bar::gl_var: [%d]\n", Bar::gl_var);
	printf("Bar::f(): [%d]\n\n", Bar::f());
	
	printf("Muf::gl_var: [%d]\n", Muf::gl_var);
	printf("Muf::f(): [%d]\n\n", Muf::f());
	
	printf("::gl_var: [%d]\n", ::gl_var);// équivaut à printf("gl_var: [%d]\n", gl_var);
	printf("::f(): [%d]\n\n", ::f());
	
	return (0);

}

Fin exemple.

NB : compilation avec g++ -Wall -Wextra -Werror 

Verifier la compilation avec le flag : -std=c++98

Un namespace est très souvent utilisé : le namespace std:: ou namespace standard dans lequel se
trouve toute la bibliothèque standard de C++.

-----------------------------------------------------------------------------------------------

Vidéo 42 : Stdio streams

Gestion des entrées et des sorties.

NB : à titre de comparaison, en language C, les fonctions write et read permettent
respectivement d'écrire sur la sortie standard (STDOUT) et de lire sur l'entrée standard (STDIN).
Write nécessite de déclarer un fd et read de déclarer un buffer.
La syntaxe de CPP simplifie ces actions. 

CPP met à disposition des objets cin et cout qui vont correspondre respectivement à l'entrée et
à la sortie standard.
CPP met également à disposition deux opérateurs << et >> pour permettre de gérer ces flux de
données.

Exemple :

#include <iostream.h>// include pour utiliser cin et cout 

	char buff[512];//tableau de 512 caractères

int	main(void){
	std::cout << "Hello world !" << std:endl;//endl = retour à la ligne
	
	std::cout << "Input a word : ";
	std::cin >> buff;
	std::cout << "You entered : [" << buff << "]" std::endl;
	
	return 0;
}

NB : cplusplus.com

-----------------------------------------------------------------------------------------------

Vidéo 42 : Class and instance

Déclarer une classe et définir une classe

Convention de nommage de headers :
Si le nom de la classe est "Sample", le nom du fichier commencera par "Sample".
Ensuite pour être certain que l'on a bien affaire à une classe, le nom du fichier se poursuivra
par la pré-extention class ce qui permet de savoir que l'on a affaire à un header de classe.
L'extension proposée est hpp (pas obligatoire mais évite que l'éditeur n'interprète le header
comme un header de C, ce qui est toutefois configurable).
Le nom du fichier sera "Sample.class.hpp".

Convention de nommage de fichiers source :
Le fichier de source sera nommé de la même façon : "Sample.class.cpp".


Déclaration d'une classe en CPP :

Exemple de contenu du fichier Sample.class.hpp :

#ifndef SAMPLE_CLASS_H
# define SAMPLE_CLASS_H

class Sample { //nouvelle structure de données

public: //sera vu ultérieurement

	Sample(void); //déclaration d'un constructeur à partir du nom de la classe
	~Sample(void); //déclaration d'un destructeur à partir du nom de la classe

}; //ne pas oublier le point-virgule

#endif

NB : lorsque la classe est instanciée, la fonction de construction est appelée.
lorsque l'instance est détruite, la fonction de destruction est appelée.


Définir les fonctions contenues dans la classe :

Exemple de contenu du fichier Sample.class.cpp :

#include <iostream>
#include "Sample.class.hpp"

Sample::Sample(void){ //définition du constructeur sample de la classe sample qui ne prend
			aucun paramètre et n'a aucun type de retour (on peut considérer le
			constructeur comme une procédure)
			(NB : la syntaxe "::" rappelle celle des namespaces)
	std::cout << "Constructeur called" << std::endl;
	return;
}

Sample::Sample(void){ //définition du destructeur sample de la classe sample qui ne prend
			aucun paramètre et n'a aucun type de retour (on peut considérer le
			destructeur comme une procédure)
	std::cout << "Destructeur called" << std::endl;
	return;
}


Création de l'instance (utiliser la classe) :

Comme en C, la création de l'instance utilise une syntaxe similaire à la déclaration d'une
variable soit :


#include "Sample.class.hpp"

int main(){

	Sample instance; //variable instance de type Sample
	return 0;
}

La classe est la partie statique (image du moule à gâteau).
L'instance est la partie dynamique (le gâteau).

L'instanciation de la classe a deux effets :
	- donner une variable de type Sample (une instance de classe),
	- le code du constructeur est exécuté.
Lorsque l'on sort d'une fonction en C, toutes les variables locales sont détruites. En CPP, le
code fonctionne de la même façon grâce à l'exécution du code du destructeur.

-----------------------------------------------------------------------------------------------

Vidéo 42 : Member attributes and member functions

Attribut membre : variable dans la classe qui pourra être utilisée à partir d'une instance.

Fonction membre qui appartient à la classe et qui pourra être utilisée à partir d'une instance.

NB : en langage C, ajouter une fonction à une structure est compliqué. La seule façon de procéder
est de définir un pointeur sur fonction dans la structure, de l'assigner puis de le déréférencer
pour appeler la fonction.

En CPP, possibilité de déclarer une fonction directement dans la classe. L'implémentation (la
définition) de cette fonction va fonctionner exactement sur le modèle du constructeur et du
destructeur, à la différence près d'un retour de fonction.  

Exemple de header :

#ifndef SAMPLE_CLASS_H
# define SAMPLE_CLASS_H

class Sample{

public:

	int	foo; //attribut membre
	
	Sample(void);
	~Sample(void);

	void	bar(void); // fonction membre
}:

#endif

Exemple de définition de fonction :

#include <iostream>
#include "Sample.class.hpp"

Sample::Sample(void){

	std::cout << "Constructeur called" << std::endl;
	return;
}

Sample::Sample(void){

	std::cout << "Destructeur called" << std::endl;
	return;
}

void	Sample::bar(void){

	std::cout << "Member function bar called" << std::endl;
	return;

}

NB : une subtilité en CPP car la fonction bar a un paramètre, contrairement à ce que laisse
sous-entendre le void. En réalité, un paramètre par défaut est passée à la fonction, le premier,
à savoir un pointeur sur l'instance courante (Cf. vidéo suivante).

Exemple d'instanciation :

#include "Sample.class.hpp"

int main(){

	Sample instance;
	
	instance.foo = 42;
	std::cout << "instance.foo: " << instance.foo << std::endl;
	
	instance.bar();
		
	return 0;
}

-----------------------------------------------------------------------------------------------

Vidéo 42 : THIS

Ajouter des attributs, des fonctions membre, comment faire référence à l'instance courante d'une
classe au sein du code de cette classe.

Exemple de header :

#ifndef SAMPLE_CLASS_H
# define SAMPLE_CLASS_H

class Sample{

public:

	int	foo; //attribut
	
	Sample(void);
	~Sample(void);

	void	bar(void); //fonction membre
}:

#endif


Exemple de définition de fonction :

#include <iostream>
#include "Sample.class.hpp"

Sample::Sample(void){

	std::cout << "Constructeur called" << std::endl;
	
	this->foo = 42; //this est un pointeur sur l'instance courante
	std::cout << "this->foo: " << this->foo << std:endl;
	
	this->bar();
	
	return;
}

Sample::Sample(void){

	std::cout << "Destructeur called" << std::endl;
	return;
}

void	Sample::bar(void){

	std::cout << "Member function bar called" << std::endl;
	return;

}

Exemple d'instanciation :

#include <iostream>
#include "Sample.class.hpp"

int main(){

	Sample instance;
	
	return 0;
}

-----------------------------------------------------------------------------------------------

Vidéo 42 : Initialization list

Exemple de header :

#ifndef SAMPLE1_CLASS_H
# define SAMPLE1_CLASS_H

class Sample1{

public:

	char	a1;	
	int	a2;
	float	a3;
	
	Sample1(char p1, int p2, float p3); //le constructeur prend 3 paramètres
	~Sample1(void);

}:

#endif

Il s'agit maintenant d'initialiser les 3 attributs avec les 3 paramètres du constructeur.

En utilisant le pointeur d'instance this, on peut assigner manuellement les attributs de
l'instance courante.

Exemple de définition de fonction :

#include <iostream>
#include "Sample.class1.hpp"

Sample::Sample1(char p1, int p2, float p3){ //paramètres de constructeur

	std::cout << "Constructeur called" << std::endl;
	
	this->a1 = p1;
	std::cout << "this->a1: " << this->a1 << std:endl;
	
	this->a2 = p2;
	std::cout << "this->a2: " << this->a2 << std:endl;

	this->a3 = p3;
	std::cout << "this->a3: " << this->a3 << std:endl;
	
	return;
}

Sample::Sample1(void){

	std::cout << "Destructeur called" << std::endl;
	return;
}

Cette méthode fonctionne mais à éviter (CPP propose une syntaxe particulière).


Exemple de header : // identique au précédent

#ifndef SAMPLE2_CLASS_H
# define SAMPLE2_CLASS_H

class Sample2{

public:

	char	a1;	
	int	a2;
	float	a3;
	
	Sample2(char p1, int p2, float p3); //le constructeur prend 3 paramètres
	~Sample2(void);

}:

#endif

2ème exemple de définition de fonction : // nouvelle syntaxe dite liste d'initialisation

#include <iostream>
#include "Sample.class2.hpp"

Sample::Sample2(char p1, int p2, float p3) : a1(p1), a2(p2), a3(p3) {

	std::cout << "Constructeur called" << std::endl;
	std::cout << "this->a1: " << this->a1 << std:endl;
	std::cout << "this->a2: " << this->a2 << std:endl;
	std::cout << "this->a3: " << this->a3 << std:endl;
	
	return;
}

Sample::Sample1(void){

	std::cout << "Destructeur called" << std::endl;
	return;
}

Exemple d'instanciation :

#include <iostream>
#include "Sample1.class.hpp"
#include "Sample2.class.hpp"

int main(){

	Sample1 instance1('a', 42, 4.2f);
	Sample2 instance2('z', 13, 3.14f);
		
	return 0;
}

-----------------------------------------------------------------------------------------------
