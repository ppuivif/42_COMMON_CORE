CPP

-----------------------------------------------------------------------------------------------
Vidéo 42 : introduction


Namespace : "sac"
permet de réunir au sein d'un même ensemble toutes les notions qui présentent un rapport
sémantique entre elles.

This : pointeur d'instance


-----------------------------------------------------------------------------------------------

Vidéo 42 : les namespaces

NB :
Un fichier est une unité de compilation.

Namespace : "sac"
permet de regrouper au sein d'un même ensemble (le namespace) toutes les notions (symboles,
fonctions) qui présentent un rapport sémantique entre elles.

En language C, les fichiers jouent ce rôle. Par exemple un fichier permet de manipuler des listes.
La manipulation des listes est décrite dans ce fichier. Souvent, lors de manipulations complexes,
les fichiers deviennent rapidement volumineux (de nombreux symboles, de nombreuses fonctions),
d'où la nécessité de découper en plusieurs fichiers avec toutefois la possibilité de rassembler
les symboles, non pas au niveau d'un fichier, mais de façon plus globale qui peut s'étendre sur
plusieurs fichiers. L'idée est alors de donner un nom à ce regroupement.
C'est l'idée des namespaces. 

Premier exemple :

#include <stdio.h>

int	gl_var = 1;// déclaration d'une variable globale de type entier initialisée à 1
int	f(void){return 2;}// definition d'une fonction f qui ne prend pas de paramètres, qui
				renvoie un entier et qui retourne la constante 2

namespace	Foo{// permet de rassembler des symboles que je juge liés sémantiquement

	int	gl_var = 3;
	int	f(void){return 4;}

}

namespace	Bar{

	int	gl_var = 5;
	int	f(void){return 6;}

}

namespace	Muf = Bar;// aliasing de namespace permettant d'imbriquer des namespaces les uns
				dans les autres et de simplifier la syntaxe 

//avec plusieurs namespaces portant des noms différents, on peut avoir des symboles qui ont le
même nom sans générer de conflits.

int	main(void){

	printf("gl_var: [%d]\n", gl_var);
	printf("f(): [%d]\n\n", f());

	printf("Foo::gl_var: [%d]\n", Foo::gl_var);// :: opérateur de resolution de portée
	printf("Foo::f(): [%d]\n\n", Foo::f());
	
	printf("Bar::gl_var: [%d]\n", Bar::gl_var);
	printf("Bar::f(): [%d]\n\n", Bar::f());
	
	printf("Muf::gl_var: [%d]\n", Muf::gl_var);
	printf("Muf::f(): [%d]\n\n", Muf::f());
	
	printf("::gl_var: [%d]\n", ::gl_var);// équivaut à printf("gl_var: [%d]\n", gl_var);
	printf("::f(): [%d]\n\n", ::f());
	
	return (0);

}

Fin exemple.

NB : compilation avec g++ -Wall -Wextra -Werror 

Verifier la compilation avec le flag : -std=c++98

Un namespace est très souvent utilisé : le namespace std:: ou namespace standard dans lequel se
trouve toute la bibliothèque standard de C++.

-----------------------------------------------------------------------------------------------

Vidéo 42 : Stdio streams

Gestion des entrées et des sorties.

NB : à titre de comparaison, en language C, les fonctions write et read permettent
respectivement d'écrire sur la sortie standard (STDOUT) et de lire sur l'entrée standard (STDIN).
Write nécessite de déclarer un fd et read de déclarer un buffer.
La syntaxe de CPP simplifie ces actions. 

CPP met à disposition des objets cin et cout qui vont correspondre respectivement à l'entrée et
à la sortie standard.
CPP met également à disposition deux opérateurs << et >> pour permettre de gérer ces flux de
données.

Exemple :

#include <iostream.h>// include pour utiliser cin et cout 

	char buff[512];//tableau de 512 caractères

int	main(void){
	std::cout << "Hello world !" << std:endl;//endl = retour à la ligne
	
	std::cout << "Input a word : ";
	std::cin >> buff;
	std::cout << "You entered : [" << buff << "]" std::endl;
	
	return 0;
}

NB : cplusplus.com

-----------------------------------------------------------------------------------------------


