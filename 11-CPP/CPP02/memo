Float et double

-----------------------------------------------------------------------------------------------

En programmation, les "float" et les "double" sont deux types de donn√©es utilis√©s pour
repr√©senter les nombres d√©cimaux, mais ils diff√®rent en premier lieu en terme de pr√©cision et
d'utilisation de la m√©moire.

In programming, float and double are both data types used to represent decimal numbers, but
they differ primarily in terms of precision (the number of significant digits they can store)
and memory usage.

-----------------------------------------------------------------------------------------------

Pr√©cision (precision) et exactitude (accuracy)

L'exactitude (ou justesse) fait r√©f√©rence √† la proximit√© d'une mesure (ou d'un calcul) avec la
valeur r√©elle.
e.g. : 
Imaginons que vous mesurez la longueur d'un objet qui mesure pr√©cis√©ment 10 cm. Si votre mesure
indique 9,98 cm, elle est assez exacte car elle est proche de la vraie valeur de 10 cm.

La pr√©cision fait r√©f√©rence √† la quantit√© d'informations dont on dispose sur une quantit√©.
La pr√©cision se r√©f√®re √† la consistance ou r√©p√©tabilit√© des mesures, ou √† quel point une
valeur est exprim√©e de mani√®re d√©taill√©e, ind√©pendamment de sa proximit√© avec la valeur r√©elle.
Une haute pr√©cision ne signifie pas forc√©ment exactitude ; cela signifie simplement que les
valeurs sont √©troitement regroup√©es ou tr√®s sp√©cifiques.

e.g. :
Supposons que vous mesurez le m√™me objet plusieurs fois et que vous obtenez des valeurs comme
9,01 cm, 9,02 cm, et 9,00 cm. Ces valeurs sont pr√©cises parce qu'elles sont proches les unes
des autres, mais elles ne sont pas exactes car elles sont √©loign√©es de la vraie longueur de
10 cm.

En r√©sum√© :

Haute Exactitude et Haute Pr√©cision : Les valeurs sont proches de la valeur r√©elle et entre
elles (cas id√©al).
Haute Exactitude, Basse Pr√©cision : Les valeurs sont proches de la valeur r√©elle mais
dispers√©es et peu coh√©rentes.
Basse Exactitude, Haute Pr√©cision : Les valeurs sont √©loign√©es de la valeur r√©elle mais proches
les unes des autres (erreur syst√©matique).
Basse Exactitude et Basse Pr√©cision : Les valeurs sont √©loign√©es de la valeur r√©elle et entre
elles (erreur al√©atoire).

Exemple de Visualisation
Imaginez que vous lancez des fl√©chettes sur une cible :

Exactes et Pr√©cises : Toutes les fl√©chettes atterrissent pr√®s du centre de la cible.
Exactes mais Non Pr√©cises : Les fl√©chettes sont dispers√©es autour du centre mais pas proches
les unes des autres.
Pr√©cises mais Non Exactes : Les fl√©chettes atterrissent proches les unes des autres, mais loin
du centre.
Ni Exactes Ni Pr√©cises : Les fl√©chettes sont dispers√©es au hasard sur la cible, loin du centre
et les unes des autres.

Conclusion :
En informatique, la pr√©cision est souvent d√©termin√©e par le type de donn√©es (par exemple,
float ou double), qui limite le nombre de chiffres significatifs qu‚Äôune valeur peut
repr√©senter, tandis que l‚Äôexactitude d√©pend de la proximit√© entre la valeur calcul√©e ou
mesur√©e et la valeur r√©elle ou attendue.

-----------------------------------------------------------------------------------------------

Precision and accuracy

Accuracy refers to how close a measured or computed value is to the true or actual value.
If a value is accurate, it means it represents the correct or intended answer, with minimal
error.
e.g. : Imagine you‚Äôre measuring the length of an object that is exactly 10 cm. If your
measurement reads 9.98 cm, it is fairly accurate because it‚Äôs close to the true value of 10 cm.

Precision refers to the consistency or repeatability of measurements, or how finely a value is
expressed, regardless of how close it is to the true value.
Precision is about how detailed or exact the value is, measured in significant digits. High
precision doesn‚Äôt necessarily mean accuracy‚Äîit just means the values are closely grouped
together or very specific.
e.g. : Suppose you measure the same object multiple times and get values like 9.01 cm, 9.02 cm,
and 9.00 cm. These values are precise because they are close to each other, but they are not
accurate because they are far from the true length of 10 cm.

Putting It Together :
High Accuracy, High Precision: Values are both close to the true value and to each other (ideal
case).
High Accuracy, Low Precision: Values are close to the true value but are spread out and
inconsistent.
Low Accuracy, High Precision: Values are far from the true value but are close to each other
(systematic error).
Low Accuracy, Low Precision: Values are neither close to the true value nor to each other
(random error).

Conclusion :
In computing, precision is often controlled by the data type (e.g., float or double), which
limits the number of significant digits a value can represent, while accuracy depends on how
close a computed or measured value is to the real or intended value.

sources : https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point.html
	  Chatgpt
-----------------------------------------------------------------------------------------------

Question :
Un float est il plus ou moins precis ou exact qu'un double ?

ChatGPT said:
Un float est moins pr√©cis qu'un double mais cela n‚Äôaffecte pas l'exactitude de la valeur
en elle-m√™me.

Explication

Pr√©cision :
Un float a une pr√©cision simple (32 bits), capable de repr√©senter environ 6 √† 7 chiffres
significatifs.
Un double, en revanche, a une pr√©cision double (64 bits), permettant de repr√©senter environ
15 √† 16 chiffres significatifs.
En raison de ce nombre de chiffres significatifs plus √©lev√©, un double est plus pr√©cis qu'un
float. Il peut repr√©senter les nombres avec plus de d√©tail et moins d'erreurs d'arrondi.

Exactitude :
L'exactitude d√©pend de la proximit√© entre la valeur repr√©sent√©e et la valeur r√©elle ou
attendue.
Tant que la valeur d'origine est correcte et sans erreur, float et double peuvent √™tre tout
aussi exacts.
Cependant, dans des calculs complexes, un manque de pr√©cision peut introduire des erreurs
d'arrondi cumulatives, ce qui affecte l'exactitude du r√©sultat final. Un double r√©duit le
risque de ces erreurs d'arrondi, ce qui permet de conserver une exactitude plus √©lev√©e dans
les calculs.

En R√©sum√©
Un double est plus pr√©cis qu'un float car il peut repr√©senter des nombres avec plus de
chiffres significatifs.
En termes d'exactitude, les deux types peuvent √™tre exacts, mais un double est moins
susceptible de perdre en exactitude dans des calculs n√©cessitant une grande pr√©cision.
En g√©n√©ral, pour des applications n√©cessitant une grande pr√©cision num√©rique (par exemple,
des calculs scientifiques), on pr√©f√®re utiliser double pour minimiser les erreurs d'arrondi
et pr√©server l'exactitude.

-----------------------------------------------------------------------------------------------

Repr√©sentation d'un float en syst√®me binaire (sur 32 bits) :

Un float en binaire suit la norme IEEE 754 pour les nombres √† virgule flottante en pr√©cision
simple. Cette norme divise les 32 bits en trois parties : signe, exposant et mantisse (ou
significande).

Bit de Signe (1 bit)	Exposant (8 bits)		Mantisse (23 bits)
D√©termine le signe	Encode l‚Äô√©chelle (avec biais)	Encode la pr√©cision

Le signe (1 bit) :
	- 0 pour un nombre positif,
	- 1 pour un nombre n√©gatif.

L'exposant (8 bits) :
	- l'exposant d√©termine l'√©chelle du nombre (la position de la virgule) : il encode
	la puissance de 2,
	- il est stock√© avec un biais de 127 soit : exposant r√©el + exposant stock√© - 127.
	
La mantisse (23 bits) :
	- la mantisse stocke uniquement la partie fractionnaire (le 1 initial est implicite
	pour les nombres normalis√©s),
	- elle encode la pr√©cision du nombre sous forme fractionnaire.

La formule suivante permet de repr√©senter un float sur 32 bits :
	(‚àí1)exposant Signe √ó (1.Mantisse) √ó 2 Exposant‚àí127

-----------------------------------------------------------------------------------------------

comment effectuer la conversion en nombre a virgule fixe ?

ChatGPT said:

La conversion en nombre √† virgule fixe (ou fixed-point) est une technique utilis√©e pour repr√©senter des nombres r√©els sans utiliser le format flottant, en s√©parant implicitement les parties enti√®re et fractionnaire. Voici comment cela fonctionne et comment effectuer la conversion.

1. Structure d‚Äôun Nombre √† Virgule Fixe
Un nombre √† virgule fixe utilise un entier pour repr√©senter le nombre, mais avec une position de la virgule (fixe) d√©cid√©e √† l‚Äôavance. Par exemple :

Partie enti√®re : bits les plus √† gauche.
Partie fractionnaire : bits les plus √† droite.
Exemples de repr√©sentation :
16 bits (Q8.8) :
8 bits pour la partie enti√®re.
8 bits pour la partie fractionnaire.
32 bits (Q16.16) :
16 bits pour la partie enti√®re.
16 bits pour la partie fractionnaire.
2. √âtapes pour la Conversion
Conversion d‚Äôun nombre r√©el en virgule fixe :
D√©finir l‚Äô√©chelle (scale) :

Choisissez un facteur d‚Äô√©chelle (2ùëõ) pour convertir la partie fractionnaire en entier.

Par exemple, pour un format Q8.8, l‚Äô√©chelle est 
2 exposant 8 = 256

Multiplier par l‚Äô√©chelle :

Multipliez le nombre r√©el par l‚Äô√©chelle pour d√©caler la virgule vers la droite.
Arrondir (si n√©cessaire) :

Arrondissez le r√©sultat pour obtenir un entier.
Stocker sous forme d‚Äôentier :

Le r√©sultat est stock√© comme un entier en m√©moire.
Exemple :
Convertissons 
12.34
12.34 en virgule fixe au format Q8.8.

√âchelle : 
2 exposant 8 = 256

Multiplier : 
12.34 √ó 256 = 3162.24

Arrondir : 
3162.

R√©sultat : 
3162 est stock√© comme un entier.
En m√©moire, 
3162
3162 correspond √† 
11000101101
0
2
110001011010 
2
‚Äã
  en binaire.

Conversion d‚Äôun virgule fixe en nombre r√©el :

Lire l‚Äôentier stock√©.

Diviser par l‚Äô√©chelle pour ramener la virgule √† sa place d‚Äôorigine.

Exemple :
Convertissons 3162 (Q8.8) en nombre r√©el.

Diviser : 3162 / 256 = 12.34

3. Utilisation de la Virgule Fixe
La virgule fixe est souvent utilis√©e dans des syst√®mes embarqu√©s ou pour des applications o√π les calculs doivent √™tre rapides et pr√©visibles, car :

Pas de co√ªt li√© √† la gestion de l‚Äôexposant (comme dans les nombres flottants).
Moins d'erreurs d‚Äôarrondi dans certains cas.
Compatible avec le mat√©riel sans unit√© de calcul en virgule flottante (FPU).
4. Avantages et Inconv√©nients
Avantages :
Rapidit√© : Calculs plus rapides que les nombres flottants.
Facilit√© d‚Äôimpl√©mentation : Repose sur des entiers simples.
Pr√©cision contr√¥l√©e : La pr√©cision d√©pend de l‚Äô√©chelle choisie.
Inconv√©nients :
Plage limit√©e : La plage des valeurs est fix√©e par la taille des bits.
Risque d‚Äôoverflow : Les grandes valeurs peuvent d√©passer la capacit√© de l‚Äôentier.
Complexit√© dans certains cas : Requiert un bon choix d‚Äô√©chelle pour √©viter la perte de pr√©cision.

R√©sum√©
La conversion en virgule fixe consiste √† d√©caler et stocker la valeur r√©elle comme un entier en fonction d‚Äôune √©chelle donn√©e. Cette technique est pratique dans les environnements n√©cessitant une gestion efficace des ressources.

-----------------------------------------------------------------------------------------------

Peux-tu m'expliquer dans le detail la ligne :

	int scale = 1 << 16;

ChatGPT said:

Cette ligne effectue une op√©ration simple mais importante. D√©taillons-la √©tape par √©tape :

1- Signification de l'expression 1 << 16

1 est l'entier 1 en binaire.
Sa repr√©sentation en 32 bits est  : 0000¬†0000¬†0000¬†0000¬†0000¬†0000¬†0000¬†0001

L'op√©rateur << est un d√©calage binaire √† gauche (left shift operator).

16 indique de combien de positions on d√©cale les bits vers la gauche.

En d√©calant 1 de 16 positions vers la gauche, les bits se d√©placent, ajoutant des z√©ros
√† droite. Cela revient √† multiplier 1 par 2 exposant 16.

En binaire :

Avant d√©calage : 
0000 0000 0000 0000 0000¬†0000¬†0000¬†0001

Apr√®s d√©calage : 
0000 0000 0000 0001 0000¬†0000¬†0000¬†0000 (en binaire, cela correspond √† 2 exposant 16).

2- R√©sultat num√©rique
2 exposant 16 = 65 536

Donc, apr√®s l'op√©ration, scale contient la valeur enti√®re 65536.

3. Pourquoi utiliser 1 << 16 plut√¥t que directement √©crire 65536 ?

Lisibilit√© et clart√© :

Cette notation indique clairement qu‚Äôon travaille avec une √©chelle bas√©e sur des puissances
de deux.
Cela est souvent utilis√© dans des contextes impliquant des calculs binaires (comme les
nombres √† virgule fixe).

Portabilit√© :

Cette approche fonctionne ind√©pendamment de la repr√©sentation num√©rique des entiers, assurant
une meilleure compatibilit√© entre plateformes.

4. Contexte dans le code
Dans ton exemple, scale est utilis√© comme un facteur d'√©chelle pour convertir des nombres
r√©els en virgule fixe au format Q16.16 :

La partie enti√®re et la partie fractionnaire du nombre r√©el sont encod√©es sur 16 bits chacune.
L'√©chelle 2 exposant 16 = 65536 sert √† d√©placer la virgule de 16 positions vers la droite
pour que la partie fractionnaire soit stock√©e en tant qu'entier.


R√©sum√©
La ligne int scale = 1 << 16; :

Calcule la valeur 
2 exposant 16, soit 65536, en effectuant un d√©calage binaire √† gauche.
Elle est utilis√©e comme facteur d‚Äô√©chelle pour manipuler des nombres en virgule fixe
(format Q16.16).

-----------------------------------------------------------------------------------------------

L'encodage en binaire d'un nombre √† virgule flottante :

1- d√©terminer le format d'encodage* (le nombre de bits utilis√©s pour l'encodage)
	- exemple : encodage sur 8 bits,
2- d√©terminer le mode d'encodage* (la r√©partition des bits utilis√©s pour la partie enti√®re et
ceux utilis√©s pour la partie fractionnaire)
	- exemples des 3 modes couramment utilis√©s en encodage 8 bits :
	  - mode 6.2 (6 bits pour la partie enti√®re et 2 bits pour la partie fractionnaire),
	  - mode 5.3 (5 bits pour la partie enti√®re et 3 bits pour la partie fractionnaire),
	  - mode 4.4 (4 bits pour la partie enti√®re et 4 bits pour la partie fractionnaire),
Dans ces 3 modes, on a bien 8 bits au total.
Le nombre de bits utilis√©s pour la partie fractionnaire va d√©terminer la pr√©cision de l'encodage.


* les termes utilis√©s peuvent √™tre sujets √† discussion 

