BASH REFERENCE MANUEL (RESUME)

https://www.gnu.org/software/bash/manual/bash.html

-----------------------------------------------------------------------------------------------

1.1 Qu'est-ce-que Bash ?

Bash est le shell par defaut, à savoir l'interpréteur de commandes, de GNU OS.
Il est compatible avec sh et incorpore les principales caractéristiques de ksh et csh.
Bash est relativement portable : il fonctionne sur presque toutes les versions de Unix et sur
quelques autres OS (MS-DOS, OS/2, WINDOWS).

1.2 Qu'est-ce-qu'un shell ?

Un shell est simplement un macro-processus qui execute des commandes.
En d'autres termes, c'est un outil permettant d'utiliser des textes et symboles pour créer des
expressions plus étendues.   

Un shell est à la fois un interpréteur de commandes et un language de programmation.
En tant qu'interpréteur de commande, shell offre une interface utilisateur vers les outils GNU.
Shell permet la combinaison de ces outils. En cela, il offre les fonctionnalités d'un langage de
programmation. Des fichiers contenant des commandes peuvent être créés, et deviennent en eux-même
des commandes. Ces nouvelles commandes ont les mêmes status que les commandes système.

Shell permet deux modes de fonctionnement 
	- mode interactif : il prend les entrées du clavier,
	- mode non-interactif : shell exécute les commandes lues dans un fichier.

Shell permet l'exécution des commandes :
	- de façon "synchronisée" : les commandes s'exécutent successivement dès lors que les
	commandes "additionnelles" sont reçues,
	- de façon "non synchronisée" : les commandes s'exécutent parallèlement sans attendre
	les fonctions additionnelles,

Le principe des redirections permet de gérer finement les in et output.
Shell permet également le contrôle des "commandes d'environnement".

Shell fournit des commandes dites "built-in" qui seraient difficiles à implémenter en dehors
du shell car elles manipulent directement shell (ex. cd, break, continue, exec).
Ces built-in sont implémentés dans shell, plutôt que dans des programmes quelque-part dans le
système de fichiers.

-----------------------------------------------------------------------------------------------

2 Quelques definitions :

POSIX : c'est un standard basé sur Unix

blank : espace ou carcatère de tabulation

builtin : c'est une commande qui est implémentée de façon interne par le shell lui-même et non
par un programme dans le système de fichiers.

opérateur de contrôle : c'est un token qui joue le rôle d'une fonction de contrôle. C'est une
newline ou l'un des opérateurs suivants : '||', '&&', '&', ';', ';;', ':&', '|', '|&', '(', ')'

exit status (ou return status) : valeur retournée par une commande à son "appelant". Cette valeur
est comprise entre 0 et 255.

field (champ) : c'est une unité de texte qui résulte de l'une des expansions de shell. Aprés
l'expansion, au moment de l'exécution d'une commande, les champs résultant de l'expansion sont
utilisés comme les noms de commande et les arguments.

filename : une chaîne de caractères utilisée pour identifier un fichier

job : un jeu de processus incluant un pipe, et tout processus en découlant

job control : un mécanisme par lequel les utilisateurs peuvent arrêter (supspendre) et
redémarrer (reprendre) l'exécution de processus  

metacharacter : caractère (lorsqu'il n'est pas entre quotes) faisant office de séparateur.
A metacharacter is a space, tab, newline, or one of the following characters: ‘|’, ‘&’, ‘;’, ‘(’,
 ‘)’, ‘<’, or ‘>’.
 
 
 
control operator ou redirection operator

lexer ou tokenizer (ou analyser) : opération qui consiste à prendre les entrées (input) en tant
que chaînes de caractères et à les convertir en un jeu de tokens.

token : c'est une séquence de caractères constituant une unité indivisible (mot ou opérateur).
Un token est en quelque sorte le plus petit élément « unitaire » des données à analyser.
exemple : en code, un commentaire est un token, une commande est un token, un type de variable
est un token, un nombre est un token, ...

parser (vérifier) : opération consistant à prendre les tokens issus du lexer et à vérifier la
cohérence (validité) grammaticale. Il retourne un arbre syntaxique.

-----------------------------------------------------------------------------------------------

3 Principales caractéristiques de Shell

3.1 La syntaxe :
	En lisant l'input, le shell procède en une succession d'opérations.  
	- # : symbole de commentaire. Shell ignore le symbole et le reste de la ligne,
	- shell lit l'input et divise l'input en mots et en opérateurs, à partir des règles de
	"quoting" (règles associées à l'utilisation des single ''' et double quotes'"') afin
	d'assigner une signification aux mots et caractères,
	- shell filtre ensuite ces tokens et les répartit en commandes et autres "constructions".
	- "il retire la signification spéciale de certains mots et caractères",
	- il en "expand" d'autres,
	- il redirige les in et output,
	- il exécute les commandes speciales,
	- il attend les exit status des commandes,
	- il rend ces exit status disponibles pour un contrôle ultérieur ou un processus
	ultérieur.
	
3.1.1 Le processus de lecture et d'exécution d'une commande :
	1- lecture de l'entrée depuis un fichier, depuis une string envoyée comme argument d'une
	"invocation bash" ou depuis le terminal de l'utilisateur,
	2- séparation des mots et des operateurs contenus dans l'input, en respectant les règles
	décrites dans le Quoting. Les tokens sont séparés par des métacharacters. L'expansion
	des alias est réalisée au cours de cette étape.
	3- filtre et tri des tokens en commandes simples et composées.
	4- réalisation des expansions, séparation des tokens expansés en listes de nom de fichiers,
	en commandes et arguments.
	5- réalisation des redirections et suppression des opérateurs de redirection et des
	opérandes.
	6- exécution de la commande.
	7- éventuellement attendre que la commande soit complète et collection des exit status.

3.1.2 Le quoting :
	- le quoting est utilisé pour supprimer la signification spéciale de certains caractères
	ou mots (caractéres spéciaux et mots réservés pouvant être reconnus comme tels), ceci
	afin d'éviter leur expansion. C'est le cas des metacharacters.
	- il existe 3 mécanismes de quoting :
		- l'escape character : le backslash (non quoté). Il préserve la valeur littérale
		du caractère suivant, hors newline qui est traité comme la suite de la ligne.
		- les single quotes : le fait d'encadrer une string de single quotes permet de 
		préserver la valeur littérale de la string. Un single quote seule entre single
		quotes, même si elle est précédée d'un backslash, n'est pas acceptée.
		- double quotes : le fait d'encadrer des caractères entre double quotes préserve
		la valeur littérale de chaque caractère, à l'exception de ‘$’, ‘`’, ‘\’, et de '!'
		quand l'expansion d'historique est activée (sauf en mode POSIX).
		Le backslash entre double quotes garde sa signification spéciale seulement quand
		il est suivi de ‘$’, ‘`’, ‘"’, ‘\’, or newline. Dans ces cas, il est supprimé. Si
		le backslash est suivi de caractéres sans signification particulière, il n'est pas
		supprimé.
		Un double quote précédé d'un backslash peut être placé entre double quotes.
A compléter	Cas de l'expansion historique à éclaircir avec '!'.
		Les paramètres spéciaux '*' et '@' ont des significations particulières quand ils
		sont placés entre double quotes.
	- l'ANSI-C quoting :
A compléter	Les séquences de caractères de la forme $'string' sont traités comme un cas spécial
		de single quotes.
		Cas des \a, \b, \e, ...
	- la traduction locale-specifique :
		En préfixant une string entre double quotes, cette string sera traduite
		"selon la norme locale".
A compléter	Se référer à gettext.

3.1.3 Les commentaires
	En mode non-interactif (input via un fichier), ou en mode interactif (input via la clavier)
	dans lequel l'option interactive_comments est désactivée, un mot commençant par '#' et le
	reste de la ligne seront ignorés.
	En mode interactif avec l'option activée, les commentaires ne sont pas autorisés. Cette
	option est activée par défaut.
 
3.2 Les commandes shell
 	Une commande shell simple telle que echo a b c est constituée de la commande elle-même suivie
 	des arguments séparés par des espaces.
 	Les commandes plus complexes sont constituées de commandes simples combinées ensemble de
 	plusieurs façons : dans un pipe, dans une boucle ou une "conditional construct", ou d'autres
 	groupements.
 	
3.2.1 Les mots réservés :
 	Ce sont les mots qui ont une signification particulière pour le shell. Ils sont utilisés
 	pour marquer le début et la fin des commandes combinées.
 	Ces mots sont reconnus comme mots réservés lorsqu'ils ne sont pas placés entre quotes et
 	lorsqu'ils sont en première place d'une commande (hors in et do dans une commande for).
 	Exemples : if, else, fi, time, {, [[, !, ...

3.2.2 Les commandes simples :
	Les commandes simples sont les plus fréquentes. C'est une séquence de mots séparés par des
	whitespaces, terminée par un opérateur de controle (‘|’, ‘&’, ‘;’, ‘(’, ‘)’, ‘<’, or ‘>’).
	Le premier mot spécifie généralement la commande qui doit être exécutée. Les mots suivants
	sont les arguments de la commande.
	L'exit status d'une commande simple est l'exit status tel que fourni par la fonction
	waitpid du  POSIX ou (128+n) si la commande se termine par un signal n.
	
3.2.3 Pipelines :
	Un pipeline est une séquence d'une ou plusieurs commandes séparées par l'un des operateurs
	'|' ou '|&'.
	Le format d'un pipeline est le suivant : [time [-p]] [!] command1 [ | or |& command2 ] …
	La sortie de chaque commande dans le pipeline est connectée via un pipe à l'entrée de la
	commande suivante. Ainsi, chque commande lit la sortie de la commande précédente. Cette
	connection est exécutée avant toute redirection spécifiée dans la commande 1.
	Le mot réservé time permet d'afficher des statistiques de temps concernant le pipeline
	une fois terminé. Lorsque le mode POSIX est sélectionné, shell ne reconnait pas le mot
	réservé time.
	Si le pipeline est exécuté en mode synchrone, le shell attend toutes les commandes.
	Chaque commande dans un pipeline multi-commande est exécutée dans un subshell, qui est
	un processus séparé. Si l'option lastpipe est desactivée (voir The Shopt Buitin), le
	dernier élément du pipeline peut être lancé par le processus quand le "job control" n'est
	pas actif.
	L'exit status d'un pipeline est le status exit de la dernière commande du pipeline, sauf si
	l'option pipefail est désactivée. Si le mot réservé '!' précède le pipeline, l'exit status
	est la négation logique de l'exit status décrit précédemment.
	Shell attend que toute les commandes se soient exécutées dans le pipeline, avant de retourner
	une valeur.
	
3.2.4 Listes de commandes :
	Une liste est une séquence d'un ou plusieurs pipelines séparés par l'un des opérateurs
	‘;’, ‘&’, ‘&&’, or ‘||’, et optionnellement terminés par un ‘;’, ‘&’, ou une newline.
A éclaircir	Dans cette liste d'opérateurs, ‘&&’ and ‘||’ ont la même priorité, suivi par 
	‘;’ and ‘&’ qui ont la même priorité.
	Une séquence d'une ou plusieurs newlines peut être utilisée dans une liste pour délimiter
	les commandes, comme un semicolon ';'.
	Si une commande est terminée par l'opérateur de contrôle '&', shell exécute la commande de
	façon asynchrone dans un subshell. Shell n'attend pas la fin de la commande et retourne 0.
	Quand le "job control" n'est pas actif, l'entrée standard pour les commandes asynchrones,
	en l'absence de redirections, est redirigée vers /dev/null.
	Les commandes séparées par un ';' sont exécutées séquentiellement ; shell attend que chaque
	commande se termine à tour de rôle. L'exit status est celui de la dernière commande exécutée.
	Les listes AND "&&" et OR "||" sont des séquences qui sont exécutées "en s'associant par la
	gauche".
	Exemple : command1 && command2
	la commande 2 s'exécute si et seulement si la commande 1 retourne un exit status égal à 1. 
	Exemple : command1 || command2
	la commande 2 s'exécute si et seulement si la commande 1 retourne un exit status différent
	de 1.

3.2.5 Commandes composées :
	Les commandes composées sont à la base des fonctionnalités de programmation de shell.
	Chaque construction commence par un mot réservé ou un opérateur de contrôle et se termine
	par le mot ou l'opérateur correspondant.
à éclaircir	Chaque redirection associée à une commande composée s'applique à toutes les commandes
	sauf si elles sont explicitement remplacées.
	Dans la plupart des cas, une liste de commandes dans une description de commandes composées
	peut être séparée du reste de la commande par une newline ou plus, et peut être suivie par
	une newline au lieu d'une semicolon.
	Bash fournit des construction de type boucle, de type conditionnelle, de type regroupement.
	
3.2.5.1 Les boucles :
	until, while, for
	Le metacharacter ';' peut être remplacé par une newline.
	

3.2.5.2 Les conditions
	if, case, select, ((...)), [[...]]
	
3.2.5.3 Les regroupements
	Bash offre 2 façons de grouper une liste de commandes à exécuter comme une seule.
	Quand les commandes sont groupées, les redirections peuvent s'appliquer à la totalité de
	la liste de commandes. Par exemple, la sortie de toutes les commandes dans la liste peut
	étre redirigée vers un "simple flux".
	- (list)
		Le fait de placer une liste de commandes entre parenthèses force le shell à créer
		un subshell, et chaque commande de la liste est exécutée ce cet environnement de
		subshell.
		Etant donné que la liste est exécutée dans un subshell, les assignation de variable
		disparaissent une fois le subshell terminé.
	- {list}
		Le fait de placer une liste de commandes entre brackets entraîne l'exécution dans
		le contexte du shell courant. Aucun subshell n'est créé. Le semicolon (ou la
		newline) suivant la liste est requis.
	- nota : Les brackets sont des mots reservés (ils doivent donc être separés par des
		"whitespaces" ou d'autres metacharacters.
		Les parenthèses sont des opérateurs.
	L'exit status de ces deux constructions est l'exit status de la liste.
	
3.2.6 Les coprocess
	Un coprocess est une commande shell précédée par le mot réservé 'coproc'.
	Un coprocess s'exécute de façon asynchrone dans un subshell, comme si la commande s'était
	achevée avec un opérateur de contrôle '&', avec un pipe à deux sens etabli entre le shell
	qui s'exécute et le coprocess. 	
	
3.2.7 GNU Parallel
	Il y a deux façon d'exécuter des commandes en parallèle qui ne sont pas construites dans
	Bash. GNU parallel est un outil permettant de réaliser ces actions.

3.3 Fonctions shell
	Les fonctions shell sont une façon de grouper des commandes pour une exécution ultérieure
	en utilisant un nom simple pour le groupe.
	Elles sont exécutées simplement comme des commandes "classiques". Quand le nom d'une fonction
	shell est utilisé comme une commande simple, la liste des commandes associées à cette fonction
	est exécutée. Les fonctions shell sont exécutées dans le contexte du shell courant ; aucun
	nouveau processus n'est créé pour les interpréter.
	Les fonctions sont déclarées en utilisant la syntaxe suivante :
		fname () compound-command [ redirections ]
		ou
		function fname [()] compound-command [ redirections ]
	Ce qui permet de définir une fonction shell nommée fname. L'utilisation du mot réservé
	function est facultative.

3.4 Les paramètres shell
	Un paramètre est une entité qui stocke des valeurs. Il peut s'agir d'un nom (name), d'un
	nombre, ou d'un caractère spécial (*, @, #, ?, -, $, !, 0).
	Une variable est un paramètre dénoté par un nom (name). Une variable a une valeur, et aucun
	ou plusieurs arguments (attributes). Les arguments sont assignés en utilisant le builtin
	'declare'.
	Un paramètre est defini si une valeur lui a été assignée. Une string null est une valeur
	valide. Une fois qu'une variable est définie, elle peut être (unset) en utilisant le
	builtin 'unset'.
	Une variable peut être assignée de la façon suivante :
		name=[value]
	Si value n'est pas donnée, la valeur null est assignée à la variable. Toutes les valeurs
	font l'objet d'une expansion du tilde (~), d'une expansion du paramètre et de la variable
	(ie?), d'une substitution de la commande, d'une expansion arithmétique, et d'une suppression
	des quotes. Si la variable possède son jeu d'attributs (integer attribute set), alors la
	valeur est évaluée comme une expression arithmétique même si l'expansion $(...) n'est pas
	utilisée. Le split des mots et l'expansion des noms de fichiers ne sont pas exécutés.
	
	
	
	
	
	
	
	
	
	
	
	
	
		
